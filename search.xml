<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[力扣刷题第1天]]></title>
    <url>%2Fposts%2F4cd4f6fe.html</url>
    <content type="text"><![CDATA[1. Two SumDescription： Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:1234Input:[2,7,11,15]Output:[0, 1] Idea： 采用边哈希边查找的方式来判断是否有相异的2个元素即可！时间复杂度为$ O(n) $。 Solution： C++代码 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash; // 采用无序哈希表，O(1)查询 vector&lt;int&gt; res; int tmp = 0; for(int i = 0, siz = nums.size(); i &lt; siz; ++i) &#123; tmp = target - nums[i]; if(hash.find(tmp) != hash.end()) &#123; res = vector&lt;int&gt;(&#123;hash[tmp], i&#125;); break; &#125; hash[nums[i]] = i; &#125; return res; &#125;&#125;; Java代码 1234567891011121314151617class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;(); //一般查询时间复杂度为O(1) int[] res = new int[2]; int dig = 0; for(int i = 0, siz = nums.length; i &lt; siz; ++i) &#123; dig = target - nums[i]; if(mp.containsKey(dig)) &#123; res[0] = mp.get(dig); res[1] = i; break; &#125; mp.put(nums[i], i); &#125; return res; &#125;&#125; Python3代码 12345678910class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hash_map = &#123;&#125; # 采用字典，查询速度为O(1)，缺点是占用内存大 for idx, val in enumerate(nums): # 枚举字典 other_idx = hash_map.get(target - val) if other_idx is not None: return [other_idx, idx] hash_map[val] = idx return None 提交结果 执行用时 内存消耗 语言 Accepted 8 ms 10 MB Cpp Accepted 2 ms 37.2 MB Java Accepted 56 ms 15.1 MB Python3 2. Add Two NumbersDescription： You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example:1234Input:(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output:7 -&gt; 0 -&gt; 8 Idea： 小学数学，只需按位相加，最后的进位单独处理！固定一个头指针指向答案整条链的首地址，通过另一个指针cur创建new下一个next节点，注意：要先new创建当前指针的下一个next节点再移动当前cur到下一个节点的地址处，否则将会断开整条链！ Solution： C++代码 12345678910111213141516171819202122232425262728293031323334/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* head = new ListNode(0); ListNode* cur = head; int carry = 0; while(l1 != NULL || l2 != NULL) &#123; if(l1 != NULL) &#123; carry += l1 -&gt; val; l1 = l1 -&gt; next; &#125; if(l2 != NULL) &#123; carry += l2 -&gt; val; l2 = l2 -&gt; next; &#125; cur -&gt; next = new ListNode(carry % 10); cur = cur -&gt; next; carry /= 10; &#125; if(carry &gt; 0) &#123; cur -&gt; next = new ListNode(carry); cur = cur -&gt; next; &#125; return head -&gt; next; &#125;&#125;; Java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0); ListNode cur = head; int carry = 0, sum = 0; while(l1 != null || l2 != null) &#123; ListNode now = new ListNode(0); if(l1 != null &amp;&amp; l2 != null) &#123; sum = l1.val + l2.val + carry; carry = sum / 10; now.val = sum % 10; l1 = l1.next; l2 = l2.next; &#125; else if(l1 != null) &#123; sum = l1.val + carry; carry = sum / 10; now.val = sum % 10; l1 = l1.next; &#125; else &#123; sum = l2.val + carry; carry = sum / 10; now.val = sum % 10; l2 = l2.next; &#125; cur.next = now; cur = cur.next; &#125; if(carry &gt; 0) &#123; ListNode now = new ListNode(carry); cur.next = now; cur = cur.next; &#125; return head.next; &#125;&#125; Python3代码 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: head = ListNode(0) cur = head carry = 0 # 逻辑运算符的优先级：not &gt; and &gt; or while l1 is not None or l2 is not None: if l1 is not None: carry += l1.val l1 = l1.next if l2 is not None: carry += l2.val l2 = l2.next cur.next = ListNode(carry % 10) cur = cur.next carry //= 10 if carry &gt; 0: cur.next = ListNode(carry) cur = cur.next return head.next Submission Detail： 提交结果 执行用时 内存消耗 语言 Accepted 16 ms 44.7 MB Cpp Accepted 1 ms 44.7 MB Java Accepted 76 ms 14 MB Python3 3. Longest Substring Without Repeating CharactersDescription： Given a string, find the length of the longest substring without repeating characters. Example:12345678Input:&quot;abcabcbb&quot;&quot;bbbbb&quot;&quot;pwwkew&quot;Output:313 Idea： 典型的双指针问题！以右指针为参照点，若当前右指针指向字符出现的次数大于1，则不断地移动左指针（不超过右指针），然后更新一下区间元素不重复出现的最多个数： $ max(res, ed -st + 1) $ 即可 ！时间复杂度为 $ O(n) $。python中使用字典加优化的解法，即对于当前右指针指向的字符，若有出现相同键的旧下标值，则跳到旧下标的下一个位置！ Solution： C++代码 1234567891011121314151617class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int res = 0, st = 0, ed = 0, siz = s.size(); int* num = new int[128](); //初始化一个全为0的int数组 while(ed &lt; siz) &#123; ++num[s[ed]]; while(st &lt; ed &amp;&amp; num[s[ed]] &gt; 1) &#123; --num[s[st]]; ++st; &#125; res = max(res, ed - st + 1); ++ed; &#125; return res; &#125;&#125;; Java代码 12345678910111213141516class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int res = 0, st = 0, ed = 0, siz = s.length(); int[] nums = new int[128]; while(ed &lt; siz) &#123; ++nums[s.charAt(ed)]; while(st &lt; ed &amp;&amp; nums[s.charAt(ed)] &gt; 1) &#123; --nums[s.charAt(st)]; ++st; &#125; res = Math.max(res, ed - st + 1); ++ed; &#125; return res; &#125;&#125; Python3代码 1234567891011121314class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: res, st, hash_map = 0, 0, &#123;&#125; for idx, val in enumerate(s): # 枚举遍历字符串 if val in hash_map: # 自动判断字典中是否存在一个key，存在就跳，否则不移动 tmp = hash_map[val] + 1 # O(1) 获取值 if tmp &gt; st: # 尽量用if-else语句，测试大量数据时可降低时间复杂度 st = tmp # 取左指针的最大值 num = idx - st + 1 if num &gt; res: res = num hash_map[val] = idx return res Submission Detail： 提交结果 执行用时 内存消耗 语言 Accepted 8 ms 9.9 MB Cpp Accepted 3 ms 35.9 MB Java Accepted 56 ms 14.1 MB Python3]]></content>
      <categories>
        <category>LeetCode刷题集</category>
      </categories>
      <tags>
        <tag>单链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F4a17b156.html</url>
    <content type="text"><![CDATA[测试12&lt;?php echo "Hello World!"; 引用的内容 表格文字居中样式12a34b56c78d 这是引用！ 点击展开代码块 123// 这是代码块的测试&lt;?php echo "Hello World!"; Hexo常用命令12345678hexo new post/draft &quot;postName&quot; #新建发布/草稿文章hexo new page &quot;pageName&quot; # 新建页面hexo generate # 生成静态页面至public目录hexo server # 启动服务器(默认端口4000，&apos;ctrl+c&apos;关闭server)hexo deploy # 远程部署项目hexo help # 查看帮助hexo version # 查看Hexo的版本hexo clean # 清除Hexo的缓存]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马小定理例题汇总]]></title>
    <url>%2Fposts%2Fc279d4a4.html</url>
    <content type="text"><![CDATA[hdu 6440 Dream Freshmen frequently make an error in computing the power of a sum of real numbers, which usually origins from an incorrect equation $ (m+n)^p=m^p+n^p $, where m,n,p are real numbers. Let’s call it ‘’Beginner’s Dream’’.For instance, $ (1+4)^2=5^2=25 $, but $ 1^2+4^2=17\neq25$.Moreover, $ \sqrt{9+16}= \sqrt{25}=5 $, which does not equal $ 3+4=7 $.Fortunately, in some cases when p is a prime, the identity $(m+n)^p=m^p+n^p $ holds true for every pair of non-negative integers m,n which are less than p, with appropriate definitions of addition and multiplication.You are required to redefine the rules of addition and multiplication so as to make the beginner’s dream realized.Specifically, you need to create your custom addition and multiplication, so that when making calculation with your rules the equation $ (m+n)^p=m^p+n^p $ is a valid identity for all non-negative integers m,n less than p. Power is defined as a^p=\left\{\begin{matrix} 1, & p=0 \\ a^{p-1}\cdot a, & p>0 \end{matrix}\right.Obviously there exists an extremely simple solution that makes all operation just produce zero. So an extra constraint should be satisfied that there exists an integer $q(0&lt;q&lt;p)$ to make the set $\{q^k|0&lt;k&lt;p,k\in\mathbb{Z}\}$ equal to $\{k|0&lt;k&lt;p,k\in\mathbb{Z}\}$. What’s more, the set of non-negative integers less than p ought to be closed under the operation of your definitions. Hint Hint for sample input and output:From the table we get $0+1=1$, and thus $(0+1)^2=1^2=1 \cdot 1=1$. On the other hand, $0^2=0\cdot0=0, 1^2=1\cdot1=1, 0^2+1^2=0+1=1$.They are the same. Input The first line of the input contains an positive integer $T(T\leq 30) $ indicating the number of test cases.For every case, there is only one line contains an integer $p(p&lt;2^{10})$, described in the problem description above. p is guranteed to be a prime. Output For each test case, you should print 2p lines of p integers.The j-th $(1\leq j \leq p)$ integer of i-th$(1 \leq i \leq p)$ line denotes the value of (i−1)+(j−1). The j-th $(1\leq j \leq p)$ integer of (p+i)-th $(1\leq i \leq p)$ line denotes the value of $(i−1) \cdot(j−1)$. Sample Input1212 Sample Output12340 11 00 00 1 思路： 给定素数p，定义p内封闭的加法和乘法运算，使得等式$(m+n)^p = m^p + n^p\;(0 \leq m,n&lt;p) $ 恒成立。由费马小定理可得对 $\forall \; x \in \mathbb{Z} $ 都有$x^p\equiv x\;(mod\;p)$，其中p是素数，则 $ m^p\equiv m\;(mod\;p),n^p\equiv n\;(mod\;p),(m+n)^p\equiv(m+n)\;(mod\;p)$,所以在模p的意义下，$ (m+n)^p = m^p + n^p(0 \leq m,n&lt;p),m^p \cdot n^p \equiv m\cdot n\;(mod\;p)$ 恒成立，即加法运算与乘法运算封闭。备注：运算封闭的定义：若从某个非空数集中任选两个元素（同一元素可重复选出），选出的这两个元素通过某种（或几种）运算后的得数仍是该数集中的元素，那么，就说该集合对于这种（或几种）运算是封闭的。 AC代码：1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int t,p;int main()&#123; while(cin &gt;&gt; t)&#123; while(t--)&#123; cin &gt;&gt; p; for(int i = 0; i &lt; p; ++i) for(int j = 0; j &lt; p; ++j) printf("%d%c", (i + j) % p, j == p - 1 ? '\n' : ' '); for(int i = 0; i &lt; p; ++i) for(int j = 0; j &lt; p; ++j) printf("%d%c", i * j % p, j == p - 1 ? '\n' : ' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（扩展）欧拉定理例题汇总]]></title>
    <url>%2Fposts%2F117f1053.html</url>
    <content type="text"><![CDATA[hdu 4704 SumProblem Description For gievn N,let S(k) be the number of $ (x_1, x_2, \cdots ,x_k) $ which:$ x_1, x_2, \cdots ,x_k \in \mathbb{Z}^+$$ x_1 + x_2 + \cdots + x_k = N $Find $ (S(1)+S(2)+\cdots+S(N)) \;mod\;(10^9+7)$. Input The first line contains an integer N. $(1\leq N\leq 10^{100000}) $ Output An integer denotes the values. Sample Input12 Sample Output12 Hint 1.For N = 2, S(1) = S(2) = 1.2.The input file consists of multiple test cases. 思路： $S(i)$ 表示将N划分为i个数的方案数，举个栗子：当N=4时，S(1)=4,1种方案；S(2)=1+3=3+1,2种方案；S(3)=1+1+2=1+2+1=2+1+1,3种方案；S(4)=1+1+1+1,1种方案,一共7种方案。那么原问题就转化成小球隔板问题：将N个1排成一行，有N-1个空，每个空可以选择插入或者不插入一块隔板，则一共有 $2^{N-1}$ 种方案数。因为指数非常大，且 $\gcd(2,10^9+7)=1$，所以要用扩展欧拉定理来降幂，即 $ 2^{(N-1)\%\varphi(1e9+7)} \;(mod\;1e9+7)$。 AC代码：12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL mod = 1e9+7;string str; LL n, phi;LL quick_mod(LL a, LL b) &#123; LL res = 1LL; while(b) &#123; if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; while(cin &gt;&gt; str) &#123; n = 0LL, phi = mod - 1LL; for(int i = 0; str[i]; ++i) n = (n * 10LL + (str[i] - '0')) % phi; //φ(p) = p - 1 cout &lt;&lt; quick_mod(2LL, n - 1LL) &lt;&lt; endl; // 2^(n - 1) % p &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>（扩展）欧拉定理例题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂&快速乘法取模例题汇总]]></title>
    <url>%2Fposts%2Fcf940335.html</url>
    <content type="text"><![CDATA[luogu P1226.【模板】快速幂||取余运算题目描述: 输入b，p，k的值，求 $b^p$ mod k的值。其中b，p，k * k为长整型数。 输入格式： 三个整数b,p,k. 输出格式： 输出“b^p mod k=s”，s为运算结果。 输入样例：12 10 9 输出样例：12^10 mod 9=7 思路： 特判一个坑点：1^0 mod 1 = 0。 AC代码1：123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL a, b, mod;LL quick_mul(LL a, LL b, LL mod)&#123; //快速乘法取模 LL res = 0LL; while(b) &#123; if(b &amp; 1) res = (res + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; &#125; return res;&#125;LL quick_mod(LL a, LL b, LL mod) &#123; //快速幂取模 LL res = 1LL; while(b) &#123; if(b &amp; 1) res = quick_mul(res, a, mod); a = quick_mul(a, a, mod); b &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; while(cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod) &#123; cout &lt;&lt; a &lt;&lt; "^" &lt;&lt; b &lt;&lt; " mod " &lt;&lt; mod &lt;&lt; "=" ; if(b == 0LL &amp;&amp; mod == 1LL) cout &lt;&lt; 0 &lt;&lt; endl; //特判 else cout &lt;&lt; quick_mod(a, b, mod) &lt;&lt; endl; &#125; return 0;&#125; AC代码2：12345tot = input().split()a = int(tot[0])b = int(tot[1])mod = int(tot[2])print(str(a) + "^" + str(b) + " mod " + str(mod) + "=" + str(pow(a, b, mod))) luogu T50035 我才是签到题题目描述： 输入b，p，k的值，求 $ b^p $ mod k的值。 输入格式： 输入三个整数b,p,k. 输出格式： 输出答案 输入样例：12 10 9 输出样例：17 说明 $ 0 \leq b, p &lt; 2^{63} $$ 1 \leq k&lt; 2^{63} $ 思路： 注意数据类型全开unsigned long long，同样特判：1^0 mod 1 = 0。 AC代码1：1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long LL;LL a, b, mod;LL quick_mul(LL a, LL b, LL mod)&#123; //快速乘法 LL res = 0LL; while(b) &#123; if(b &amp; 1) res =(res + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; &#125; return res;&#125;LL quick_mod(LL a, LL b, LL mod) &#123; //快速幂取模 LL res = 1LL; while(b) &#123; if(b &amp; 1) res = quick_mul(res, a, mod); a = quick_mul(a, a, mod); b &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; while(cin &gt;&gt; a &gt;&gt; b &gt;&gt; mod) &#123; if(b == 0LL &amp;&amp; mod == 1LL) cout &lt;&lt; 0 &lt;&lt; endl; //特判 else cout &lt;&lt; quick_mod(a % mod, b, mod) &lt;&lt; endl; &#125; return 0;&#125; AC代码2：12345tot = input().split()a = int(tot[0])b = int(tot[1])mod = int(tot[2])print(pow(a, b, mod))]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>快速幂&amp;快速乘法取模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（扩展）中国剩余定理例题汇总]]></title>
    <url>%2Fposts%2Fc20e7b39.html</url>
    <content type="text"><![CDATA[luogu P3868.[TJOI2009]猜数字题目描述： 现有两组数字，每组k个，第一组中的数字分别为：$ a_1,a_2,\cdots,a_k $ 表示，第二组中的数字分别用 $ b_1,b_2,\cdots,b_k$ 表示。其中第二组中的数字是两两互素的。求最小的非负整数n，满足对于任意的 $ i,n - a_i $ 能被 $ b_i $ 整除。 输入格式： 输入数据的第一行是一个整数 $ k,(1\leq k \leq 10)$。接下来有两行，第一行是：$ a_1,a_2,\cdots,a_k $，第二行是$ b_1,b_2,\cdots,b_k$。 输出格式： 输出所求的整数n。 输入样例：12331 2 32 3 5 输出样例：123 说明 所有数据中，第一组数字的绝对值不超过 $ 10^9 $（可能为负数），第二组数字均为不超过6000的正整数，且第二组里所有数的乘积不超过 $ 10^{18} $。每个测试点时限1秒。注意：对于C/C++语言，对64位整型数应声明为long long，如使用scanf, printf函数（以及fscanf, fprintf等），应采用%lld标识符。 思路： 要使得 $ b_i | (n-a_i) $，则有 $n\equiv a_i \;(mod\; b_i)$，即问题求解转化为裸的中国剩余定理。为避免数据溢出，要处理一下两个坑点：①余数都要先处理为绝对值最小的整数；②因为直接乘法取模容易发生数据溢出，所以要改为快速乘法取模运算！ AC代码1：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 15;LL n, r[maxn], m[maxn];LL ext_gcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if(b == 0LL) &#123;x = 1LL; y = 0LL; return a;&#125; LL res = ext_gcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - a / b * y; return res;&#125;LL quick_mul(LL a, LL b, LL mod)&#123;//快速乘法，防止两数相乘爆long long，时间复杂度为log(b) LL res = 0LL; while(b) &#123; if(b &amp; 1) res =(res + a) % mod; a = (a + a) % mod; //每次乘2 b &gt;&gt;= 1; &#125; return res;&#125;LL crt(LL *r, LL *m, LL n) &#123; //中国剩余定理 LL lcm = 1LL, res = 0LL, M_i, x, y; for(LL i = 0; i &lt; n; ++i) lcm *= m[i]; //先求出所有方程的最小公倍数 for(LL i = 0; i &lt; n; ++i) &#123; M_i = lcm / m[i]; ext_gcd(M_i, m[i], x, y); x = (x % m[i] + m[i]) % m[i]; //取最小非负整数解 //res = (res + r[i] * M_i * x) % lcm; res = (res + quick_mul(quick_mul(M_i, r[i], lcm), x, lcm)) % lcm; &#125; return res;&#125;int main() &#123; while(cin &gt;&gt; n) &#123; for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; r[i]; for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; m[i], r[i] = (r[i] % m[i] + m[i]) % m[i]; //余数的绝对值不超过模数的绝对值 cout &lt;&lt; crt(r, m, n) &lt;&lt; endl; &#125; return 0;&#125; AC代码2：1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 15;LL n, r[maxn], m[maxn];LL ext_gcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if(b == 0LL) &#123;x = 1LL; y = 0LL; return a;&#125; LL res = ext_gcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - a / b * y; return res;&#125;LL ext_crt(LL *r, LL *m, LL n) &#123; //扩展中国剩余定理 LL lcm = m[0], res = r[0], x, y, gcd, mod; for(LL i = 1; i &lt; n; ++i) &#123; gcd = ext_gcd(lcm, m[i], x, y); if((r[i] - res) % gcd) return -1; x *= (r[i] - res) / gcd; mod = m[i] / gcd; x = (x % mod + mod) % mod; res = res + lcm * x; lcm = lcm / gcd * m[i]; &#125; return res;&#125;int main() &#123; while(cin &gt;&gt; n) &#123; for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; r[i]; for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; m[i], r[i] = (r[i] % m[i] + m[i]) % m[i]; //余数的绝对值不超过模数的绝对值 cout &lt;&lt; ext_crt(r, m, n) &lt;&lt; endl; &#125; return 0;&#125; poj 2891 Strange Way to Express IntegersProblem Description Elina is reading a book written by Rujia Liu, which introduces a strange way to express non-negative integers. The way is described as following:Choose k different positive integers $ a_1,a_2,\cdots,a_k $. For some non-negative m, divide it by every $a_i (1 \leq i \leq k)$ to find the remainder ri. If $ a_1,a_2,\cdots,a_k $ are properly chosen, m can be determined, then the pairs $(a_i, r_i) $ can be used to express m.“It is easy to calculate the pairs from m, ” said Elina. “But how can I find m from the pairs?”Since Elina is new to programming, this problem is too difficult for her. Can you help her? Input The input contains multiple test cases. Each test cases consists of some lines.Line 1: Contains the integer k.Lines $ 2 \sim k + 1 $: Each contains a pair of integers $a_i, r_i (1 \leq i \leq k) $. Output Output the non-negative integer m on a separate line for each test case. If there are multiple possible values, output the smallest one.If there are no possible values, output -1. Sample Input12328 711 9 Sample Output131 Hint All integers in the input and the output are non-negative and can be represented by 64-bit integral types. 思路： 裸的扩展中国剩余定理。 AC代码：1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;typedef long long LL;const int maxn = 1e6+5;LL n, r[maxn], m[maxn];LL ext_gcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if(b == 0LL) &#123;x = 1LL; y = 0LL; return a;&#125; LL res = ext_gcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - a / b * y; return res;&#125;LL ext_crt(LL *r, LL *m, LL n) &#123; LL lcm = m[0], res = r[0], x, y, gcd, mod; for(LL i = 1; i &lt; n; ++i) &#123; gcd = ext_gcd(lcm, m[i], x, y); if((r[i] - res) % gcd) return -1; x *= (r[i] - res) / gcd; mod = m[i] / gcd; x = (x % mod + mod) % mod; res = res + lcm * x; lcm = lcm / gcd * m[i]; //先除后乘，避免数据溢出 &#125; return res;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); while(cin &gt;&gt; n) &#123; for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; m[i] &gt;&gt; r[i]; cout &lt;&lt; ext_crt(r, m, n) &lt;&lt; endl; &#125; return 0;&#125; hdu 1573 X问题Problem Description 求在小于等于N的正整数中有多少个X满足：X mod a[0] = b[0], X mod a[1] = b[1], X mod a[2] = b[2], …, X mod a[i] = b[i], … (0 &lt; a[i] &lt;= 10)。 Input 输入数据的第一行为一个正整数T，表示有T组测试数据。每组测试数据的第一行为两个正整数 $N,M (0 &lt; N \leq 1000000000, 0 &lt; M \leq 10)$，表示X小于等于N，数组a和b中各有M个元素。接下来两行，每行各有M个正整数，分别为a和b中的元素。 Output 对应每一组输入，在独立一行中输出一个正整数，表示满足条件的X的个数。 Sample Input12345678910310 31 2 30 1 2100 73 4 5 6 7 8 91 2 3 4 5 6 710000 101 2 3 4 5 6 7 8 9 100 1 2 3 4 5 6 7 8 9 Sample Output123103 思路： 裸的扩展中国剩余定理。 AC代码：12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 15;LL T, n, k, tot, ans, r[maxn], m[maxn];LL ext_gcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if(b == 0LL) &#123;x = 1LL; y = 0LL; return a;&#125; LL res = ext_gcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - a / b * y; return res;&#125;LL ext_crt(LL *r, LL *m, LL n, LL sum) &#123; LL lcm = m[0], res = r[0], x, y, gcd, mod; for(LL i = 1; i &lt; n; ++i) &#123; gcd = ext_gcd(lcm, m[i], x, y); if((r[i] - res) % gcd) return -1; x *= (r[i] - res) / gcd; mod = m[i] / gcd; x = (x % mod + mod) % mod; res = res + lcm * x; lcm = lcm / gcd * m[i]; &#125; if(res &gt; sum) return -1; else return (sum - res) / lcm + (res != 0); //求解res + lcm * k ≤ sum&#125;int main() &#123; while(cin &gt;&gt; T) &#123; while(T--) &#123; cin &gt;&gt; tot &gt;&gt; n; for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; m[i]; for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; r[i]; ans = ext_crt(r, m, n, tot); cout &lt;&lt; (ans == -1 ? 0 : ans) &lt;&lt; endl; &#125; &#125; return 0;&#125; hdu 3579 Hello KikiProblem Description One day I was shopping in the supermarket. There was a cashier counting coins seriously when a little kid running and singing “门前大桥下游过一群鸭，快来快来 数一数，二四六七八”. And then the cashier put the counted coins back morosely and count again…Hello Kiki is such a lovely girl that she loves doing counting in a different way. For example, when she is counting X coins, she count them N times. Each time she divide the coins into several same sized groups and write down the group size $ M_i $ and the number of the remaining coins $ A_i $ on her note.One day Kiki’s father found her note and he wanted to know how much coins Kiki was counting. Input The first line is T indicating the number of test cases.Each case contains N on the first line, $ M_i(1 \leq i \leq N)$ on the second line, and corresponding $ A_i(1 \leq i \leq N)$ on the third line.All numbers in the input and output are integers.$ 1 \leq T \leq 100, 1 \leq N \leq 6, 1 \leq M_i \leq 50, 0 \leq A_i &lt; M_i $ Output For each case output the least positive integer X which Kiki was counting in the sample output format. If there is no solution then output -1. Sample Input12345672214 575 56519 54 40 24 8011 2 36 20 76 Sample Output12Case 1: 341Case 2: 5996 思路： 裸的扩展中国剩余定理。注意：求最小的正整数解。 AC代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 10;LL T, n, k, ans, r[maxn], m[maxn];LL ext_gcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if(b == 0LL) &#123;x = 1LL; y = 0LL; return a;&#125; LL res = ext_gcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - a / b * y; return res;&#125;LL ext_crt(LL *r, LL *m, LL n) &#123; LL lcm = m[0], res = r[0], x, y, gcd, mod; for(LL i = 1; i &lt; n; ++i) &#123; gcd = ext_gcd(lcm, m[i], x, y); if((r[i] - res) % gcd) return -1; x *= (r[i] - res) / gcd; mod = m[i] / gcd; x = (x % mod + mod) % mod; res = res + lcm * x; lcm = lcm / gcd * m[i]; &#125; return res ? res : (res + lcm); //求最小的正整数解&#125;int main() &#123; while(cin &gt;&gt; T) &#123; for(LL cas = 1; cas &lt;= T; ++cas) &#123; cin &gt;&gt; n; for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; m[i]; for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; r[i]; cout &lt;&lt; "Case " &lt;&lt; cas &lt;&lt; ": "; cout &lt;&lt; ext_crt(r, m, n) &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>（扩展）中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂&快速乘法取模模板]]></title>
    <url>%2Fposts%2Fdaf04bcb.html</url>
    <content type="text"><![CDATA[快速乘法取模：$O(log^b) $ 举个栗子：3 \times 11 = 3 \times (1011)_2 = 3 \times [(1000)_2 + (000)_2 + (10)_2 + (1)_2 ]$ = 3 \times [8 + 0 + 2 + 1] = 33 $。 123456789LL quick_mul(LL a, LL b, LL mod)&#123; LL res = 0LL; //注意初始值为0 while(b) &#123; if(b &amp; 1) res =(res + a) % mod; a = (a + a) % mod; b &gt;&gt;= 1; &#125; return res;&#125; 快速幂取模：$O(log^b) $ 举个栗子：$3^{11} = 3^{(1011)_2}=3^{(1000)_2}\times 3^{(000)_2}\times 3^{(10)_2} \times 3^{(1)_2}= 3^8\times 3^0\times 3^2\times 3^1$ 1234567891011121314151617181920LL quick_mul(LL a, LL b, LL mod)&#123; //快速乘法取模 LL res = 0LL; //注意初始值为0 while(b) &#123; if(b &amp; 1) res =(res + a) % mod; a = (a + a) % mod; //每次扩大2倍 b &gt;&gt;= 1; &#125; return res;&#125;LL quick_mod(LL a, LL b, LL mod) &#123; //快速幂取模 LL res = 1LL; //注意初始值为1 while(b) &#123; if(b &amp; 1) res = quick_mul(res, a, mod); // res = res * a % mod; a = quick_mul(a, a, mod); //a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;]]></content>
      <categories>
        <category>ACM模板</category>
      </categories>
      <tags>
        <tag>快速幂&amp;快速乘法取模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（扩展）中国剩余定理模板]]></title>
    <url>%2Fposts%2Fe22674eb.html</url>
    <content type="text"><![CDATA[中国剩余定理：$ O(nlog^n)$ 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 15;LL n, r[maxn], m[maxn];LL ext_gcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if(b == 0LL) &#123;x = 1LL; y = 0LL; return a;&#125; LL res = ext_gcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - a / b * y; return res;&#125;LL quick_mul(LL a, LL b, LL mod)&#123;//快速乘法，防止两数相乘爆long long，时间复杂度为log(b) LL res = 0LL; //注意是0，不是1 while(b) &#123; //按b的二进制展开，然后累加二进制位对应a的幂次，同时取模 if(b &amp; 1) res =(res + a) % mod; //b中有1则累加a的值，进行加法运算 a = (a + a) % mod; //a每次乘2并取模 b &gt;&gt;= 1; &#125; return res;&#125;//中国剩余定理：模数两两互质LL crt(LL *r, LL *m, LL n) &#123; LL lcm = 1LL, res = 0LL, M_i, x, y; for(LL i = 0; i &lt; n; ++i) lcm *= m[i]; //先求出所有方程的模数的最小公倍数 for(LL i = 0; i &lt; n; ++i) &#123; M_i = lcm / m[i]; //除当前方程的模数外的最小公倍数 ext_gcd(M_i, m[i], x, y); x = (x % m[i] + m[i]) % m[i]; //取最小非负整数解 //res = (res + r[i] * M_i * x) % lcm; res = (res + quick_mul(quick_mul(r[i], M_i, lcm), x, lcm)) % lcm; //快速乘法取模，避免直接相乘导致数据溢出 &#125; return res;&#125; 扩展中国剩余定理：$ O(nlog^n)$1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 15;LL T, n, ans, r[maxn], m[maxn];//求解二元一次方程：ax + by = gcd(a,b)LL ext_gcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if(b == 0LL) &#123;x = 1LL; y = 0LL; return a;&#125; //不妨假设 y=0，则x=1 LL res = ext_gcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - a / b * y; //x'=y,y'=x-a/b*y return res; //返回上一个状态&#125;//扩展中国剩余定理：模数两两不都互素LL ext_crt(LL *r, LL *m, LL n) &#123; //余数：r，模数：m，同余方程个数：n LL lcm = m[0], res = r[0], x, y, gcd, mod; for(LL i = 1; i &lt; n; ++i) &#123; gcd = ext_gcd(lcm, m[i], x, y); //求最大公约数 if((r[i] - res) % gcd) return -1; //无解 x *= (r[i] - res) / gcd; //一个解 mod = m[i] / gcd; //对应的模数 x = (x % mod + mod) % mod; //最小非负整数解 res = res + lcm * x; //合并后的方程的余数 lcm = lcm / gcd * m[i]; //合并后的方程的模数，先除后乘，避免数据溢出 &#125; return res; //答案&#125;]]></content>
      <categories>
        <category>ACM模板</category>
      </categories>
      <tags>
        <tag>（扩展）中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（扩展）欧几里得算法模板]]></title>
    <url>%2Fposts%2F9a0f7abe.html</url>
    <content type="text"><![CDATA[欧几里得算法：$ O(log^n)$1234//求两个整数的最大公约数：gcd(a, b) = gcd(b, a % b)LL gcd(LL a, LL b) &#123; return b ? gcd(b, a % b) : a;&#125; 扩展欧几里得算法：$ O(log^n)$1234567//求解二元一次方程：ax + by = gcd(a,b)LL ext_gcd(LL a, LL b, LL &amp;x, LL &amp;y) &#123; if(b == 0LL) &#123;x = 1LL; y = 0LL; return a;&#125; //不妨假设 y=0，则x=1 LL res = ext_gcd(b, a % b, x, y); LL tmp = x; x = y, y = tmp - a / b * y; //x'=y,y'=x-a/b*y return res; //返回上一个状态&#125;]]></content>
      <categories>
        <category>ACM模板</category>
      </categories>
      <tags>
        <tag>（扩展）欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[威尔逊定理例题汇总]]></title>
    <url>%2Fposts%2F54c860b1.html</url>
    <content type="text"><![CDATA[hdu 5391 Zball in Tina TownProblem Description Tina Town is a friendly place. People there care about each other.Tina has a ball called zball. Zball is magic. It grows larger every day. On the first day, it becomes 1 time as large as its original size. On the second day,it will become 2 times as large as the size on the first day. On the n-th day,it will become n times as large as the size on the (n-1)-th day. Tina want to know its size on the (n-1)-th day modulo n. Input The first line of input contains an integer T, representing the number of cases.The following T lines, each line contains an integer n, according to the description.$ T \leq 10^5,2 \leq n \leq 10^9 $ Output For each test case, output an integer representing the answer. Sample Input1232310 Sample Output1220 思路： 求 $ (n-1)! \; mod \; n $。注意：特判 n = 4 时，$ ans = 2 $。 AC代码：12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int t,n;bool check(int x)&#123; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;int main()&#123; while(~scanf("%d", &amp;t))&#123; while(t--)&#123; scanf("%d", &amp;n); if(n == 4) puts("2"); //特判 6 ≡ 2(mod 4) else if(check(n)) printf("%d\n", n - 1); //如果是素数，那么取模之后为n-1，其余情况下余数为0 else puts("0"); &#125; &#125; return 0;&#125; hdu 2973 YAPTCHAProblem Description The math department has been having problems lately. Due to immense amount of unsolicited automated programs which were crawling across their pages, they decided to put Yet-Another-Public-Turing-Test-to-Tell-Computers-and-Humans-Apart on their webpages. In short, to get access to their scientific papers, one have to prove yourself eligible and worthy, i.e. solve a mathematic riddle.However, the test turned out difficult for some math PhD students and even for some professors. Therefore, the math department wants to write a helper program which solves this task (it is not irrational, as they are going to make money on selling the program).The task that is presented to anyone visiting the start page of the math department is as follows: given a natural n, compute S_n = \sum_{k=1}^n \left[\frac{(3k+6)!+1}{3k+7}-\left[\frac{(3k+6)!}{3k+7}\right] \right]where $ [x] $ denotes the largest integer not greater than x. Input The first line contains the number of queries t $ (t \leq 10^6) $. Each query consist of one natural number n $ (1 \leq n \leq 10^6) $. Output For each n given in the input output the value of $ S_n $. Sample Input12345678910111213141312345678910100100010000 Sample Output123456789101112130112222334282071609 思路： 威尔逊定理：$ (p-1)! \equiv -1\;(mod\;p) \Leftrightarrow (p-1)!+1 \equiv 0 \;(mod\;p) $。①当 $ 3k + 7 $ 是素数时，$ (3k+7)|[(3k+6)!+1] $，令 $ m=\frac{(3k+6)!+1}{3k+7} $，则 $ \left [ \frac{(3k+6)!}{3k+7} \right ] = \left [ \frac{m(3k+7)-1}{3k+7} \right ] = \left [ m-\frac{1}{3k+7} \right ] = m-1 $，此时，$ T_k = \left [ m - (m-1) \right ] =1 $；②当 $ 3k + 7 (\ge10)$ 是合数时，由威尔逊定理的相关证明可知当 $ p &gt; 4 $ 且p为合数时，$ (p-1)! \equiv 0 \;(mod \; p) $，令 $ m=\frac{(3k+6)!}{3k+7} $，则 $ \frac{(3k+6)!+1}{3k+7} = \frac{m(3k+7)+1}{3k+7} = m+\frac{1}{3k+7} $，此时，$ T_k = \left [ m+\frac{1}{3k+7}-m \right ] = \left [ \frac{1}{3k+7} \right ] = 0 $。n最大只有 $ 10^6 $，预处理打表即可。 AC代码：1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 3e6 + 50;const int maxv = 1e6 + 5;bool isp[maxn]; int T, n, cnt = 0, prime[maxn], ans[maxv];void euler_sieve()&#123; memset(isp, true, sizeof(isp)); memset(prime, 0, sizeof(prime)); isp[0] = isp[1] = false; for(int i = 2; i &lt; maxn; ++i)&#123; if(isp[i]) prime[cnt++] = i; for(int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt; maxn; ++j)&#123; isp[i * prime[j]] = false; if(i % prime[j] == 0) break; &#125; &#125;&#125;int main()&#123; euler_sieve(); memset(ans, 0, sizeof(ans)); for(int i = 1; i &lt; maxv; ++i)&#123; //预处理，求1~n范围内，3 * i + 7 是素数的个数 if(isp[3 * i + 7]) ans[i] = ans[i - 1] + 1; else ans[i] = ans[i - 1]; &#125; while(cin &gt;&gt; T)&#123; while(T--)&#123; cin &gt;&gt; n; cout &lt;&lt; ans[n] &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>威尔逊定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客寒假算法基础集训营6]]></title>
    <url>%2Fposts%2F30b4a593.html</url>
    <content type="text"><![CDATA[A.出题题目描述： 小B准备出模拟赛。她把题目按难度分为四等，分值分别为6,7,8,9。已知小B共出了m道题，共n分。求小B最少出了多少道6分题。 输入描述: 两个正整数n,m 输出描述: 一个数，表示答案。若无解，输出”jgzjgzjgz”。 输入1234534 532 55 1 输出1234513jgzjgzjgz 备注： $ n,m \leq 10^{12} $ 思路： 简单数学！这题比赛时居然没做出来qwq，就差在草稿纸上写一下不等式……显然有解的充要条件是 $ 6m \leq n \leq 9m $。若有解：设有 $ x \; (0 \leq x \leq m) $ 道6分题，则剩下的 $ m-x $ 题共 $ n-6x $ 分，其有解的充要条件为 $ 7(m-x) \leq n-6x \leq 9(m-x) $，解得 $ 7m-n \leq x \leq \frac{9m-n}{3} $，即答案为 $ max(0, 7m-n) $。（像这类求最少的问题可以根据题目条件列出不等式找答案qwq） AC代码：1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL n, m;int main() &#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; if(6LL * m &gt; n || n &gt; 9LL * m ) puts("jgzjgzjgz"); else cout &lt;&lt; max(0LL, 7LL * m - n) &lt;&lt; endl; &#125; return 0;&#125; B.煤气灶题目描述： 小j开始打工，准备赚钱买煤气灶。第一天，小j的工资为n元，之后每天他的工资都比前一天多d元。已知煤气灶需要m元，求小j最少工作几天才能买到煤气灶。 输入描述: 四个整数 $ n,m,d,x $ 分别表示小j第一天的工资，煤气灶的价格，工资每天的增长量，答案不超过x 输出描述: 一个数表示答案 输入110 100 20 100 输出14 说明 10+30+50+70&gt;=100 备注: $ 0 \leq n,d \leq 10^9,n+d&gt;0 $$ 1 \leq m \leq 10^{18} $$ 1 \leq x \leq 10^9 $ 思路： 简单的等差数列求和！因为数据太大，所以既不能暴力也不能直接用求根公式解未知数x。正解：二分答案！做这道题早就想到要二分了，但交了2发WA之后发现爆long long，于是简单地写了个python再交一发就过了。赛后看了一下题解，get新技能：用除法代替乘法避免爆long long。假设小j工作了k天，则总工资 $ = n \times k + d \times \frac{k(k-1)}{2} \ge m $，移项整理得：$ d \times k(k-1) \ge 2(m-n \times k) $。因为 $ a \times b \ge c \Leftrightarrow a \ge \left \lceil \frac{c}{b} \right \rceil $，其中 $ \left \lceil x \right \rceil $ 表示将x上取整，所以判别式分两种情况：①若 $ d = 0 $，则不等式变为 $ n \times k \ge m $；②若 $ d \neq 0 $，则不等式变为 $ k(k-1) \ge \left \lceil \frac{2(m-n \times k)}{d} \right \rceil = \frac{2(m-n \times k) +(d -1)}{d} $，以此为条件进行二分，这样就避免了不等式左边爆long long的情况。求解一元二次方程常用二分解法！ AC代码：123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL inf = 1e9;LL n, m, d, x, lt, rt, mid, ans;bool check(LL k) &#123; if(!d) return n * k &gt;= m; else return k * (k - 1LL) &gt;= (2LL * (m - n * k) + d - 1LL) / d;&#125;int main() &#123; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; d &gt;&gt; x) &#123; lt = 1LL, rt = inf, ans = x; //若没有进行二分判断，那么ans为给定的x while(lt &lt;= rt) &#123; mid = (lt + rt) &gt;&gt; 1; if(check(mid)) ans = mid, rt = mid - 1LL; //若满足条件，则找更少的天数，即右区间左移 else lt = mid + 1LL; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; C.项链题目描述： 小B想给她的新项链染色。现在有m种颜色，对于第i种颜色，小B有a_i单位的颜料，每单位颜料可以染项链的一个珠子；同时，小B对于第i种颜色的喜爱度为b_i。已知项链有n个珠子，求染色后每个珠子的颜色的喜爱度之和的最大值。(每个珠子只能至多被染一次，不被染色则喜爱度为0) 输入描述: 第一行两个数n,m第二行m个数 $ a_i $第三行m个数 $ b_i $ 输出描述: 一个数表示答案 输入12345675 31 2 33 2 15 31 2 13 2 1 输出12398 备注： $ 1 \leq n,m \leq 10^5, 0 \leq a_i,b_i \leq 10^6 $ 思路： 按喜爱度降序排，依次贪心即可。 AC代码：123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5+5;struct node&#123;LL a, b;&#125; nod[maxn];int n, m; LL ans;bool cmp(node xx, node yy) &#123;return xx.b &gt; yy.b;&#125;int main() &#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; ans = 0LL; for(int i = 0; i &lt; m; ++i) cin &gt;&gt; nod[i].a; for(int i = 0; i &lt; m; ++i) cin &gt;&gt; nod[i].b; sort(nod, nod + m, cmp); for(int i = 0; i &lt; m; ++i) &#123; if(n - nod[i].a &gt;= 0) ans += nod[i].a * nod[i].b, n -= nod[i].a; else &#123;ans += nod[i].b * n; break;&#125; //注意：剩下的珠子计算完之后直接break掉 &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D.美食题目描述： 小B喜欢美食。现在有n个美食排成一排摆在小B的面前，依次编号为 $ 1 \cdots n $，编号为i的食物大小为 $ a[i] $，即足够小B吃 $ a[i] $ 口。小B每次会吃两口，这两口要么是编号相同的美食，要么是编号之差的绝对值为1的美食。小B想知道，她最多能吃几次？ 输入描述: 第1行一个正整数n，表示美食个数接下来n行，第i行一个整数 $ a[i] $，表示编号为i的美食的大小 输出描述: 一个数表示小B最多吃几次。 输入1234541578 输出110 说明 用二元组(a,b)表示某一次吃的两个美食分别为第a个美食和第b个美食，则下面为一个吃10次的方案：$ (1,2)(2,2)(2,2)(3,4)(3,4)(3,4)(3,4)(3,4)(3,4)(3,4) $注意不一定要吃完。 备注: $ 1 \leq n \leq 10^5, 0 \leq a[i] \leq 10^9 $ 思路： 简单贪心！模拟一下样例即可得出策略。 AC代码：123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5+5;LL n, a[maxn], ans;int main() &#123; while(cin &gt;&gt; n) &#123; ans = 0LL; memset(a, 0, sizeof(a)); for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; for(LL i = 0; i &lt; n; ++i) &#123; if(a[i] % 2 == 1 &amp;&amp; a[i + 1] &gt; 0LL) ans++, a[i + 1]--; ans += a[i] / 2; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; E.海啸题目描述 有一个沿海地区，可以看作有n行m列的城市，第i行第j列的城市海拔为 $ h[i][j] $。由于沿海，所以这个地区经常会发生海啸。海啸发生时，部分城市会被淹没，具体来说，海水高度会达到d，因此海拔低于d的城市都会被淹没。现在有q次询问，每次问你一个矩形区域中，有多少城市不会被淹没。 输入描述: 第一行三个整数n,m,d，具体含义见题目描述。接下来n行，每行m个整数，其中第i行第j列的整数为 $ h[i][j] $，具体含义见题目描述。第n+2行一个整数q，表示询问数。接下来q行，每行四个整数a,b,x,y，表示询问从第a行第b列到第x行第y列的矩形地区中，有多少地区不会被淹没。即有多少个i,j，满足 $ a \leq i \leq x,b \leq j \leq y $，且 $ h[i][j] \ge d $ 。 输出描述: 共q行，第i行一个整数，表示第i个询问的答案。 输入12345673 3 31 2 32 1 54 3 221 2 2 32 1 3 3 输出1223 备注: $ 1 \leq n×m \leq 10^6 $$ 1 \leq q \leq 10^5 $$ 0 \leq d,h[i][j] \leq 10^9 $$ 1 \leq a \leq x \leq n, 1 \leq b \leq y \leq m $ 思路： 二维树状数组求前缀和！注意：vector容器的大小要么一开始申请好，要么push_back往容器加元素，但后者大小取决于压入元素的个数。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e6+5;vector&lt;int&gt; vec[maxn], num[maxn];int n, m, d, a, b, x, y, q;inline int read()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;void add(int x, int y, int val)&#123; for(int i = x; i &lt;= n; i += i &amp; -i) for(int j = y; j &lt;= m; j += j &amp; -j) num[i][j] += val;&#125;int query(int x, int y)&#123; int ans = 0; for(int i = x; i &gt; 0; i -= i &amp; -i) for(int j = y; j &gt; 0; j -= j &amp; -j) ans += num[i][j]; return ans;&#125;int main() &#123; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;d)) &#123; for(int i = 0; i &lt;= n; ++i) vec[i].clear(), num[i].clear(); //先清理 for(int i = 0; i &lt;= n; ++i) vec[i].resize(m + 5), num[i].resize(m + 5); //再申请二维空间 for(int i = 1; i &lt;= n ; ++i) &#123; for(int j = 1; j &lt;= m; ++j) &#123; vec[i][j] = read(); if(vec[i][j] &gt;= d) add(i, j, 1); &#125; &#125; q = read(); while(q--) &#123; a = read(), b = read(), x = read(), y = read(); printf("%d\n", query(x, y) - query(a - 1, y) - query(x, b - 1) + query(a - 1, b - 1)); &#125; &#125; return 0;&#125; F.石头剪刀布题目描述： wzms 今年举办了一场剪刀石头布大赛，bleaves 被选为负责人。比赛共有 $ 2^n $ 个人参加，分为n轮，在每轮中，第 1 位选手和第 2 位选手对战，胜者作为新的第 1 位选手，第 3 位和第 4 位对战，胜者作为新的第 2 位选手，以此类推。bleaves 调查得知，每个人都有其偏爱决策，每个人在每一次对战中都会使用他的偏爱决策。如果一次对战的双方的偏爱决策相同，那么这次对战就永远不会结束，所以 bleaves 不希望这种情况发生。现在 bleaves 知道了每个人的偏爱决策，但她不知道如何安排初始的次序，使得上面的情况不会发生，你能帮帮她吗？ 输入描述: 一行三个整数 R,P,S ，表示偏爱石头，布，剪刀的人数分别为 R,P,S 。 输出描述: 如果无解，输出 IMPOSSIBLE ；否则输出一个长度为 $ R+P+S $ 的字符串，第i个字符表示初始时第i位选手的偏爱决策，如果有多种方案，输出字典序最小的。 输入123451 1 02 0 01 1 2 输出12345PRIMPOSSIBLEPSRS 说明 只有 2 个选手，一个偏爱石头，一个偏爱布，无论次序如何，偏爱布的选手都会胜出。所以方案可以是 PR 和 RP ，其中字典序最小的 PR 。 备注: 全部的输入数据满足：$ R+P+S=2^n, 1 \leq n \leq 20 $。 思路： 这道题应该是整场较难的了，若能想到下面这位大佬的解法（个人觉得非常好理解），那就简单多了，很感谢某位已AK的大佬赛后提供的精彩题解，Orz！根据大佬的思路，重新整理了一下想法：根据获胜者的偏爱决策可以推出对战的两人的偏爱决策，所以这题要先从结局来反推初始状态的3个已知量是否有解。若有解，只需根据偏爱决策来递归处理字典序即可。先规定一下：0代表石头，1代表布，2代表剪刀。若最后一场获胜者为1（布），根据偏爱决策可得最后一局的组合为（1，0），倒数第二局的组合为（1，0）和（0，2），倒数第三局的组合为（1，0）……从结局枚举到之前的状态可知若一轮比赛结束时的状态确定了，则这轮比赛刚开始时的状态也一定是确定的。举个栗子：假设一轮比赛结束后，剩下x个0，y个1，z个2，那么这轮比赛开始时，一定有这样的组合：x局（0，2），y局（1，0），z局（2，1）。设一轮比赛开始时有A个0，B个1，C个2，则有 $ A = x + y, B = y + z, C = x + z $，解得 $ x=\frac{A+C-B}{2}, y=\frac{A+B-C}{2}, z=\frac{B+C-A}{2} $。于是，我们就找到了递归（终止）条件：根据题目已给的A,B,C，递归求解下一场的状态，若最终能化成0,0,1的状态，则说明存在一种策略，否则不存在。接下来就更简单了，通过前面已推得最终的获胜者，那么就可以反推出之前所有的比赛情况，所以只需先递归下来求出结果，然后每次回溯时都判断一下输出最小字典序即可。 AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int stone, cloth, scissors, winner; //石头、布，剪刀，赢家int check(int _stone, int _cloth, int _scissors) &#123; if(_stone &lt; 0 || _cloth &lt; 0 || _scissors &lt; 0) return -1; if(_stone == 0 &amp;&amp; _cloth == 0 &amp;&amp; _scissors == 0) return -1; if(_stone == 1 &amp;&amp; _cloth == 0 &amp;&amp; _scissors == 0) return 0; //石头赢 if(_stone == 0 &amp;&amp; _cloth == 1 &amp;&amp; _scissors == 0) return 1; //布赢 if(_stone == 0 &amp;&amp; _cloth == 0 &amp;&amp; _scissors == 1) return 2; //剪刀赢 return check((_stone + _scissors - _cloth) &gt;&gt; 1, (_stone + _cloth - _scissors) &gt;&gt; 1, (_cloth + _scissors - _stone) &gt;&gt; 1);&#125;string get_ans(int _winner, int _stat) &#123; if(_stat == 1) &#123; if(_winner == 0) return "RS"; //石头赢 else if(_winner == 1) return "PR"; //布赢 else return "PS"; //剪刀赢 &#125; if(_winner == 0) &#123; //石头 string s1 = get_ans(0, _stat &gt;&gt; 1); string s2 = get_ans(2, _stat &gt;&gt; 1); if(s1 &lt; s2) return s1 + s2; //字典序最小 else return s2 + s1; &#125;else if(_winner == 1) &#123; //布 string s1 = get_ans(1, _stat &gt;&gt; 1); string s2 = get_ans(0, _stat &gt;&gt; 1); if(s1 &lt; s2) return s1 + s2; else return s2 + s1; &#125;else &#123; //剪刀 string s1 = get_ans(2, _stat &gt;&gt; 1); string s2 = get_ans(1, _stat &gt;&gt; 1); if(s1 &lt; s2) return s1 + s2; else return s2 + s1; &#125;&#125;int main() &#123; while(cin &gt;&gt; stone &gt;&gt; cloth &gt;&gt; scissors) &#123; winner = check(stone, cloth, scissors); if(winner == -1) &#123;puts("IMPOSSIBLE"); continue;&#125; //无解 cout &lt;&lt; get_ans(winner, (stone + cloth + scissors) &gt;&gt; 1) &lt;&lt; endl; &#125; return 0;&#125; G.区间或和题目描述： 求 $ a|(a+1)|(a+2)| \cdots |(b-1)|b $ 。其中|表示 [按位或]。 输入描述: 多组输入，每行两个数表示a和b 输出描述: 对于每组输入，输出一个数 $ a|(a+1)|(a+2)| \cdots |(b-1)|b $。 输入1234599 10968 7755 6634 431111234 1114321 输出1234511179127471179647 备注: 输入不超过10000行，$ 0 \leq a,b \leq 10^{18}, a \leq b $ 思路： 先标记区间左右端点值的二进制中1的位置，然后枚举63个二进制位，再标记一下区间左端点a加上每一位对应的十进制值是否不超过b，最后累加一下二进制中所有被标记为1的位对应的十进制数即可。 AC代码：12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 65;LL a, b, ans, bit[maxn];int main() &#123; while(cin &gt;&gt; a &gt;&gt; b) &#123; memset(bit, 0, sizeof(bit)); ans = 0; for(LL i = 0LL; i &lt; 63; ++i) &#123; if((1LL&lt;&lt;i) &amp; a) bit[i] = 1; if((1LL&lt;&lt;i) &amp; b) bit[i] = 1; &#125; for(LL i = 0; i &lt; 63; ++i) &#123; if((1LL&lt;&lt;i) + a &lt;= b) bit[i] = 1; else break; &#125; for(LL i = 0; i &lt; 63; ++i) if(bit[i]) ans += 1LL&lt;&lt;i; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; H.肥猪题目描述： 小B来到了一个异世界，成为了肥猪之王。在这个异世界，共有n种肥猪，编号分别为 $ 1,\cdots,n $。小B希望集齐这n种肥猪。召集肥猪有两种方式：1.花费 $ a[i] $ 的金币召唤一只编号为i的肥猪。2.花费x的金币使所有已召集的肥猪进化。即编号为i的肥猪编号变成i+1，特殊的，编号为n的肥猪编号变成1。请问小B最少要花多少金币才能集齐n种肥猪。 输入描述: 第一行两个正整数n,x接下来n行，第i行一个正整数 $ a[i] $ 输出描述: 一个数表示答案 输入1234567892 101204 101234 输出1231210 备注： $ 1 \leq n \leq 2000, 1 \leq x, a[i] \leq 10^9 $. 思路： 由题可知，小B最多使用n-1次进化技能。数组a表示不使用进化技能下每种猪的召集成本，数组b表示使用了j个进化技能后，每种猪对应的最小召集成本。解法：暴力枚举 $ 1 \sim n - 1 $ 次进化，求出其中（花费x或 $ a[i] $ 的金币）召集的最小代价即可！ AC代码：123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 2005;LL n, x, ans, tmp, a[maxn], b[maxn];int main() &#123; while(cin &gt;&gt; n &gt;&gt; x) &#123; ans = 0LL; for(LL i = 0; i &lt; n; ++i) cin &gt;&gt; a[i], ans += (b[i] = a[i]); for(LL j = 1; j &lt; n; ++j) &#123; //至多使用n-1次技能 tmp = x * j; for(LL i = 0; i &lt; n; ++i) &#123;//n种（要进化的）肥猪 if(b[(i + j) % n] &gt; a[i]) tmp += (b[(i + j) % n] = a[i]); //更新b数组第i种猪第j次进化后得到的最小召集成本 else tmp += b[(i + j) % n]; &#125; ans = min(ans, tmp); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; I.wzoi题目描述： bleaves 最近在 wzoi 上面做题。wzoi 的题目有两种，一种是 noip 题，一种是省选题。bleaves 的做题方式很特别。每一天，她可能会看一道题目，这时她会选择题目种类，然后 wzoi 会在选定种类中随机扔给她一道她还没看过的题，她会把这道题看一遍，然后存在脑子里慢慢思考；她也有可能写题，这时她一定会写没写过的题中看的时间最迟的一题(如果不存在没写过的且没看过的题，她就不能写题)。wzoi 每天会有一个推荐的题目种类，如果 bleaves 看一道题目：如果种类和推荐的相同，那么这道题目最大得分为10，否则为5；如果 bleaves 写一道题目：如果种类和推荐的相同，那么这道题目得分为最大得分，否则为最大得分-5；假如 bleaves 现在还没看过任何一题，并且她知道了 wzoi 接下来一些天每天推荐的种类，问她在这些天的最大得分。 输入描述: 一行一个01串 s ，|s| 表示天数，$ s_i=0 $ 表示 wzoi 第 i 天推荐 noip 题，$ s_i=1 $ 表示 wzoi 第 i 天推荐省选题。 输出描述: 一行一个整数最大得分。 输入12345001101010110 输出12345201020 说明： 样例一：4天行动依次为：看一道 noip 题，写第1天看的题，看一道省选题，写第3天看的题。样例二：4天行动依次为：看一道 noip 题，写第1天看的题，看一道noip题，写第3天看的题。样例三：4天行动依次为：看一道 noip 题，看一道省选题，写第2天看的题，写第1天看的题。 备注: 全部的输入数据满足：$ 1 \leq n \leq 10^6 $, n 为偶数。 思路： 把看题视作左括号，做题视作右括号，那么问题就转化成简单的括号匹配问题（比赛时没来得及看QWQ）。如果能匹配，那么就能得10分，否则只能得5分，栈模拟即可！ AC代码：12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1005;string str; int cnt;stack&lt;char&gt; st;int main() &#123; while(cin &gt;&gt; str) &#123; while(!st.empty()) st.pop(); cnt = 0; for(int i = 0; str[i]; ++i) &#123; if(st.empty()) st.push(str[i]); else if(st.top() != str[i]) st.push(str[i]); else st.pop(), cnt ++; &#125; cout &lt;&lt; st.size() / 2 * 5 + cnt * 10 &lt;&lt; endl; &#125; return 0;&#125; J.迷宫题目描述 你在一个 n 行 m 列的网格迷宫中，迷宫的每一格要么为空，要么有一个障碍。你当前在第 r 行第 c 列(保证该格子为空)。每次移动你可以向上下左右任意一个方向移动一格，前提是不能走到障碍上，也不能超出迷宫的边界。你向左移动的次数不能超过 x 次，向右不能超过 y 次。问在这种情况下，对于每个格子，是否存在一种移动方案让你走到它。输出有多少个格子存在移动方案让你走到它。 输入描述: 第一行两个正整数 n,m 。第二行两个正整数 r,c ，保证 $ 1 \leq r \leq n,1 \leq c \leq m $。第三行两个整数 x,y ，保证 $ 0 \leq x,y \leq 10^9 $ 。接下来 n 行，每行一个长度为 m 的字符串，第 i 行第 j 个字符表示迷宫第 i 行第 j 列的格子，字符为. 表示格子为空，字符为* 表示格子上有一个障碍。 输出描述: 输出一个数，表示有多少个格子存在移动方案让你走到它。 输入1234567891011121314154 53 21 2......***....***....4 42 20 1......*......... 输出123107 说明12345678910样例一：将能走到的格子用+标记：+++..+***.+++***+++.样例二：.++..+*..++..++. 备注: 对于全部数据， $ 1 \leq n,m \leq 1000 $。 思路： 简单的bfs。从起点 $ (r,c) $ 向左或向右移动后到达的每个坐标点都被赋予2个已有的左移和右移状态量，求满足那些左移状态量不超过x，右移状态量不超过y的坐标点个数。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1005;char mp[maxn][maxn];int n, m, r, c, x, y, ans, dir[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;, dist[maxn][maxn];struct node&#123; int dx, dy, gay_l, gay_r; node(int _x, int _y, int _gay_l, int _gay_r) : dx(_x), dy(_y), gay_l(_gay_l), gay_r(_gay_r) &#123;&#125;&#125;;queue&lt;node&gt; que;bool check(int dxx, int dyy) &#123; if(dxx &lt; 0 || dyy &lt; 0 || dxx &gt;= n || dyy &gt;= m ) return false; return true;&#125;void bfs(int _x, int _y, int _gay_l, int _gay_r) &#123; while(!que.empty()) que.pop(); que.push(node(_x, _y, _gay_l, _gay_r)); dist[_x][_y] = 0; while(!que.empty()) &#123; node nod = que.front(); que.pop(), ans++; for(int i = 0; i &lt; 4; ++i) &#123; int nx = nod.dx + dir[i][0], ny = nod.dy + dir[i][1]; if(check(nx, ny) &amp;&amp; mp[nx][ny] != '*' &amp;&amp; dist[nx][ny] &gt; dist[nod.dx][nod.dy] + 1) &#123; dist[nx][ny] = dist[nod.dx][nod.dy] + 1; if(i == 0 || i == 1) que.push(node(nx, ny, nod.gay_l, nod.gay_r)); if(i == 2 &amp;&amp; nod.gay_l &lt; x) que.push(node(nx, ny, nod.gay_l + 1, nod.gay_r)); if(i == 3 &amp;&amp; nod.gay_r &lt; y) que.push(node(nx, ny, nod.gay_l, nod.gay_r + 1)); &#125; &#125; &#125;&#125;int main() &#123; while(cin &gt;&gt; n &gt;&gt; m) &#123; memset(dist, 0x3f, sizeof(dist)); ans = 0; cin &gt;&gt; r &gt;&gt; c; cin &gt;&gt; x &gt;&gt; y; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; mp[i]; bfs(r - 1, c - 1, 0, 0); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客竞赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客寒假算法基础集训营5]]></title>
    <url>%2Fposts%2Fa9bdf429.html</url>
    <content type="text"><![CDATA[A.炫酷双截棍题目描述： 小希现在手里有一个连着的两块木条，长度分别为$ l_1,l_2 $，木条之间有一个无摩擦的连接点，木条之间可以相互转动，小希将其称之为双截棍。现在小希把长为 $ l_1 $ 的木条的一端放在原点 $ (0,0) $，任意转动这两根木条，小希想知道，是否有可能通过一种转动方式使得双截棍的另一端到达指定点呢?如果不能，请输出所有能到达的点中离目标点最近的距离。 输入描述： 第一行输入一个两个正整数 $ l_1,l_2 $，表示木条长度。第二行输入一个正整数T，表示询问次数。随后T行，每行两个实数 $ x_i,y_i $ 表示目标点的坐标。$ l_1,l_2 \leq 1000 $$ T \leq 1000 $$ |x|,|y| \leq 10000 $ 输出描述： 对于每次询问，如果可以到达，输出0，如果无法到达，给出所有能到达的点中离目标点最近的距离。你的答案将被认为是正确的，如果相对误差不大于 $ 10^{-6} $。 输入1234523 13315 140 00 0 输出1230.000000004.0000000010.00000000 思路： 签道题！有2点需要注意：①不同类型的数据使用不同类型的绝对值函数；②两个浮点数相等的判定方法：若其差的绝对值小于某个精度，则默认相等。 AC代码：12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const double precision = 1e-6;int T, l1, l2, minus_a, plus_a; double x, y, z;int main() &#123; while(~scanf("%d%d", &amp;l1, &amp;l2)) &#123; minus_a = abs(l1 - l2), plus_a = l1 + l2; //整数用abs()函数 scanf("%d", &amp;T); while(T--) &#123; scanf("%lf%lf", &amp;x, &amp;y); x = fabs(x), y = fabs(y); //浮点数用fabs()函数 z = sqrt(x * x + y * y); if((minus_a &lt; z || fabs(z - minus_a) &lt; precision) &amp;&amp; (z &lt; plus_a || fabs(plus_a - z) &lt; precision)) printf("%.8f\n", 0.0); //如果两个实数相等，则其差的绝对值小于某个精度 else printf("%.8f\n", min(fabs(z - minus_a), fabs(z - plus_a))); &#125; &#125; return 0;&#125; D.炫酷路途题目描述： 小希现在要从寝室赶到机房，路途可以按距离分为N段，第i个和i+1个是直接相连的，只需要一秒钟就可以相互到达。炫酷的是，从第i个到第 $ i+2^p $ 个也是直接相连的（其中p为任意非负整数），只需要一秒钟就可以相互到达。更炫酷的是，有K个传送法阵使得某些u,v之间也是直接相连的，只需要一秒钟就可以相互到达，当然，由于设备故障，可能会有一些u=v的情况发生。现在小希为了赶路，她需要在最短的时间里从寝室(编号为1)到达机房(编号为N)，她不希望到达这N个部分以外的地方（不能到达位置N+1），也不能走到比自己当前位置编号小的地方（比如从5走到3是非法的）。她想知道最短的时间是多少。 输入描述: 第一行输入两个整数N,K，表示路途的段数和传送法阵的数量。从第二行开始K行，每行两个整数 $ a_i,b_i $ 表示两个位置之间相连。$ 2 \leq N \leq 1000000000 $$ 0 \leq K \leq 15 $ 输出描述: 输出一个整数，表示从寝室到机房最短的时间是多少秒。 输入123456712 21 56 617 22 58 9 输出12331 思路： 补这道题新学了不少东西：①C++STL中的unique函数，注意，一般是先排序，再去重，其返回值是一个迭代器，它指向的是去重后容器中不重复序列的最后一个元素的下一个元素。②用lowbit(int x)函数求一个整数x的二进制中’1’的个数（x &amp; -x：求x的二进制中最低位1表示的10进制数）。因为从第i个到第 $ i+2^p $ 个也是直接相连的（其中p为任意非负整数），所以把两个点之间的距离 $ \sum_{p = 1}^k 2^p $ 转换成二进制，二进制中有k个1说明要走k步。③G++编译环境中，__builtin_popcount(unsigned int x)可以 $ O(1)$ 计算x的二进制中’1’的个数。题解：将所有额外连边的点再加上起点终点构成一张单独的有向图，然后计算这些点两两间的距离并求起点到终点最短路即可。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839#pragma GCC optimize (3) //吸氧#pragma GCC target ("popcnt") //加速/**===========__builtin_xxx()函数的头文件================**/#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n, m, a[20], b[20], dist[32];vector&lt;int&gt; vec;int count_bits(int x) &#123; //求x的二进制数中'1'的个数 int cnt = 0; for(int i = x; i &gt; 0; i -= i &amp; -i) cnt++; return cnt;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); while(cin &gt;&gt; n &gt;&gt; m) &#123; vec.clear(); memset(dist, 0x3f, sizeof(dist)); vec.push_back(1), vec.push_back(n); for(int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; a[i] &gt;&gt; b[i]; if(a[i] &gt; b[i]) swap(a[i], b[i]); //保证从小的编号到大的编号 vec.push_back(a[i]), vec.push_back(b[i]); &#125; sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end()); //先排序，再去重 dist[0] = 0; //起点到自身的距离为0 for(size_t i = 0; i &lt; vec.size(); ++i) &#123; for(size_t j = i + 1; j &lt; vec.size(); ++j) &#123; for(int k = 0; k &lt; m; ++k) if(vec[i] == a[k] &amp;&amp; vec[j] == b[k]) dist[j] = min(dist[j], dist[i] + 1); //若有传送法阵，则尝试着更新最短时间 dist[j] = min(dist[j] , dist[i] + __builtin_popcount(vec[j] - vec[i])); //操作的时间复杂度是0(1) //dist[j] = min(dist[j] , dist[i] + count_bits(vec[j] - vec[i])); //操作的时间复杂度是O(logn) &#125; &#125; cout &lt;&lt; dist[vec.size() - 1] &lt;&lt; endl; &#125; return 0;&#125; E.炫酷划线题目描述： 平面上有一个圆，圆环上按顺时针顺序分布着从1到n，一共n个点。现在无聊的小希开始按某种顺序对其在圆内两两连线，小希尽量避免让两条线碰撞，可是有的时候，这显然避免不了。现在你知道小希划线的顺序是什么，请你判断小希在最优情况下，什么时候会被迫使得线相交，输出最早的时刻（是第几条线）。 输入描述： 数据第一行一个整数T，表示数据组数。每组数据第一行输入两个整数N,M，代表点的个数和游戏进行的轮数。随后M行，每行两个整数 $ a_i,b_i $，表示两个点之间连线。数据保证每个点最多被连线一次。$ T \leq 10 $$ 1 \leq N,M \leq 100000 $$ 1 \leq ai,bi \leq 100000 $ 输出描述: 对于每组数据，一行。如果中途某一条线开始无法避免相交，则输出当轮轮数。否则，输出-1。 输入123456789210 45 31 92 67 104 21 23 4 输出124-1 思路： 题意转化为：读入一些区间，输出直到有区间交叉的第一个轮数。做法：用树状数组维护，每连一条线，给其所在区间打上不同标记，然后对区间左端点和右端点进行求和，（重点判断依据）若左端点的和等于右端点的和，说明区间中没有其他线段加入，即没有交叉区间，否则就输出当轮轮数。涨知识了！ AC代码：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 100005;int T; LL n, m, a, b, tree[maxn]; bool flag;inline LL read()&#123; LL x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;void add(LL x, LL v) &#123; for(LL i = x; i &lt;= n; i += i &amp; -i) tree[i] += v;&#125;LL query(LL x) &#123; LL res = 0LL; for(LL i = x; i &gt; 0; i -= i &amp; -i) res += tree[i]; return res;&#125;int main() &#123; while(~scanf("%d", &amp;T)) &#123; while(T--) &#123; memset(tree, 0, sizeof(tree)); n = read(), m = read(); flag = false; for(LL i = 1; i &lt;= m; ++i) &#123; a = read(), b = read(); if(flag) continue; if(a &gt; b) swap(a, b); add(a, i), add(b + 1, -i); //打标记，赋予不同值，这样才能区分是否有交叉区间 //cout &lt;&lt; query(a) &lt;&lt; ' ' &lt;&lt; query(b) &lt;&lt; endl; if(query(a) != query(b)) &#123; //若左端点值不等于右端点值，说明肯定有交叉区间 flag = true; printf("%lld\n", i); &#125; &#125; if(!flag) printf("-1\n"); &#125; &#125; return 0;&#125; G.炫酷数字题目描述： 小希希望你构造一个最小的正整数，使得其有n个因子。 输入描述： 第一行一个整数T表示数据组数每组数据第一行输入一个正整数n，表示其因子数。$ n \leq 1000000 $$ T \leq 1000000 $ 输出描述： 输出一行一个整数，表示你构造出的这个数。注意：你需要保证你构造的数 $ \leq 10^6 $，如果在这个范围里面无法构造出一个正整数满足条件，请输出-1。 输入123245 输出12616 思路： 做这题时第一反应就是约数个数定理，然后胡思乱想（未果，期间还尝试着用dfs写，但感觉情况很复杂），不知如何构造这个最小正整数……赛后看了题解恍然大悟QWQ，只需通过埃氏筛法 $ O(nlog^{log^n}) $ 统计 $ 1 \sim 10^6 $ 中每个数的因子个数，然后标记一下具有 $ 1 \sim 10^6 $ 个因子对应的最小正整数即可QWQ。 AC代码：123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e6+1;int T, n, ans[maxn], cnt[maxn];int main() &#123; memset(cnt, 0, sizeof(cnt)); memset(ans, -1, sizeof(ans)); for(int i = 1; i &lt; maxn; ++i) &#123; for(int j = i; j &lt; maxn; j += i) cnt[j]++; //累加j的因子个数 if(ans[cnt[i]] == -1) ans[cnt[i]] = i; //具有n个因子的最小正整数 &#125; while(~scanf("%d", &amp;T)) &#123; while(T--) &#123; scanf("%d", &amp;n); printf("%d\n", ans[n]); &#125; &#125; return 0;&#125; I.炫酷镜子题目描述： 小希拿到了一个镜子块，镜子块可以视为一个N x M的方格图，里面每个格子仅可能安装\或者/的镜子,会反射90°光线，也可能没有安装镜子，使用.代替。但她看不清楚里面的镜子构造是怎样的。你是这块镜子块的主人，所以你想计算这块镜子块（从输入的上方往下射入光线）从左到右每一格射入依次分别会从最下面的哪一格子射出，如果无法射出，输出-1。 输入描述: 第一行输入两个整数N,M。随后的N行，每行M个字符。$ 1 \leq N,M \leq 500 $. 输出描述: 输出M行整数，依次为从第i个格子从上往下射入时从下面的哪里射出，如果光线不会从下面射出，则输出-1。 输入12343 3......\.\ 输出12332-1 说明 第一列遇到镜子两次反弹通过第三列射出。第二列直接射出。第三列因为镜子反弹后向右边射出。 思路： 简单的dfs！一开始以为会陷入死胡同，即构成四角，就用一个vis数组标记已访问过的，然后一直WA……实际上并不会构成四角，入射到的镜子可能再次入射到，且光线一定会射出边界，所以当光线射出边界时直接判断即可。注意：因为’\’是转义字符，所以判断一个字符是否为反斜杆，应为’\\’。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 505;int n, m, flag; //bool vis[maxn][maxn];char mp[maxn][maxn];void dfs(int x, int y, int c_x, int c_y) &#123; //c_x，c_y 对应四种状态：上下左右 if(flag == -1 || flag == 1) return; if(x == -1 || y == -1 || y == m ) &#123;flag = -1; printf("-1\n"); return;&#125; if(x == n) &#123;flag = 1; printf("%d\n", y + 1); return;&#125; //if(vis[x][y]) return; //无需标记是否已访问，因为光线肯定不会陷入死胡同，并且一定射出边界 //vis[x][y] = true; if(mp[x][y] == '.') dfs(x + c_x, y + c_y, c_x, c_y); else if(mp[x][y] == '/') &#123; if(c_x == 1 &amp;&amp; c_y == 0) dfs(x, y - 1, 0, -1); //下---&gt;左 else if(c_x == -1 &amp;&amp; c_y == 0) dfs(x, y + 1, 0, 1); //上---&gt;右 else if(c_x == 0 &amp;&amp; c_y == 1) dfs(x - 1, y, -1, 0); //右---&gt;上 else dfs(x + 1, y, 1, 0); //左---&gt;下 &#125; else &#123; // mp[x][y] = '\\' if(c_x == 1 &amp;&amp; c_y == 0) dfs(x, y + 1, 0, 1); //下---&gt;右 else if(c_x == -1 &amp;&amp; c_y == 0) dfs(x, y - 1, 0, -1); //上---&gt;左 else if(c_x == 0 &amp;&amp; c_y == 1) dfs(x + 1, y, 1, 0); //右---&gt;下 else dfs(x - 1, y, -1, 0); //左---&gt;上 &#125;&#125;int main() &#123; while(~scanf("%d %d", &amp;n, &amp;m)) &#123; for(int i = 0; i &lt; n; ++i) scanf("%s", mp[i]); for(int j = 0; j &lt; m; ++j) &#123; flag = 0; //memset(vis, false, sizeof(vis)); dfs(0, j, 1, 0); if(flag == 0) printf("-1\n"); &#125; &#125; return 0;&#125; J.炫酷数学题目描述 小希最近想知道一个东西，就是A+B=A|B(其中|为按位或)的二元组有多少个。当然，直接做这个式子对小希来说太难了，所以小希改变了一些条件，她仅想知道其中 $ A,B &lt; N $ 的情况，其中N为2的幂次。当然，(A=1,B=0)和(A=0,B=1)被认为是不同的二元组。 输入描述: 第一行输入一个非负整数M。$ N=2M,M \leq 100 $，即2的M次为N。 输出描述: 一个整数ans，对998244353取模。 输入123071 输出1231588378066 思路： 签道题！打表找规律：$ 3^m $。python大法好，简单粗暴！ AC代码：1print(pow(3,int(input()),998244353))]]></content>
      <categories>
        <category>牛客竞赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数论笔记整理2]]></title>
    <url>%2Fposts%2F545d3697.html</url>
    <content type="text"><![CDATA[威尔逊定理： 判定一个自然数是否为素数的充要条件：$ (p - 1)! \equiv -1 \;( mod \; p) $，当且仅当p为素数。 证明： 一、充分性（逆否命题）：若p不是素数，即p是合数，则 $ (p - 1)! \not\equiv -1 \;( mod \; p) $。特殊情况：当 $ p = 4 $ 时，$ [(p - 1) !\equiv 6 \equiv 2 \;(mod \; p)] \not\equiv -1 \;( mod \; p) $，显然成立；当 $ p &gt; 4 $ 时，分2种情况讨论：①若p不是完全平方数，则 $ \exists \; a, b \in [1, p) \land (a \neq b) $，使得 p = a * b，则 (p - 1) ! \equiv n * a * b \equiv 0 \; (mod \; p)，显然成立。②若p是完全平方数，即 $ \exists \; k &gt; 2 \land (k, 2k &lt; p) $，使得 $ p = k^2 $，则 (p - 1)! \equiv m * (k * 2k) \equiv {m}' * k^2 \equiv 0 \;(mod \; p)，显然也成立。二、必要性：若p为素数，则 $ (p - 1)! \equiv -1 \;(mod \; p) $。当 $ p = 2 \vee p = 3 $ 时，显然恒等式成立；当 $ p \ge 5 $ 时，令集合 $ A = \{1,2,3,\cdots,p-1\} $，显然集合A中每个元素都与p互质，即集合A是模p的一个缩系；令集合 $ B = \{2,3,\cdots,p-2\} $，对 $ \forall \; a \in B $，令集合 $ C = \{a,2a,\cdots,(p-1)a\} $，由缩系的性质可得集合C也是模p的一个缩系，即集合C中每个元素：模p不同余且不能被p整除。下面证明集合C是模p的一个缩系：①因为 $ (p\nmid a \in B) \land (p \nmid b \in A)$，所以素数p不整除集合C中的每个元素；②若 $ \exists \; t_1, t_2 \in A \land (t_1 \neq t_2) $，使得 t_1 * a \equiv t_2 * a \; (mod \; p)，则由同余的性质可得 |t_1 - t_2| * a \equiv 0\;(mod \; p)，又因 |t_1 - t_2| * a \in C，显然这与集合C中每一个元素不能被p整除相矛盾，所以 t_1 * a \not\equiv t_2 * a \; (mod \; p)，即集合C中每个元素模p不同余！因此，$ C \; mod \; p = A $，则对 $ \forall \; a \in B $，必 $ \exists \; b \in A $，使得 $ ab \equiv 1 \;(mod \; p) $。下面证明 $ b \notin \{1,p-1,a\} $：若 $ b = 1 $，则 $ a \equiv a \not\equiv 1 \; (mod \; p) $，显然不成立；若 $ b = p - 1 $，则 $ a(p - 1) \equiv (p - a) \not\equiv 1 (mod \; p) $，显然不成立；若 $ b = a $，则 $ a^2 \equiv 1 \;(mod \; q)$，解得 $ a = 1 \vee a = p - 1 $，因为 $ a \in B $，所以不成立。综上所述，$ \forall \; a, b \in B $，当a不同时，b也随之不同，即对于集合B中的每一个元素a都能够找到一个与之配对的b，使得 $ ab \equiv 1 \;(mod \; p) $，所以 (p - 1) ! \equiv 1 * 2b_1 * \cdots * (p - 1) (mod \; p) \equiv 1 * (p -1) (mod \; p) \equiv -1 (mod \; p).证毕！ 备注： ①剩余类（也称同余类）：设模数为m，则根据余数可将所有的整数分为m类，把所有与整数a模m同余的整数构成的集合叫做模m的一个剩余类，记作 $ [a] $，并把a叫作剩余类 $ [a] $ 的一个代表元。②简化剩余系（也称既约剩余系、缩系）：如果一个模m的剩余类里面的数与m互素（显然，只需有一个与m互素，其余的均与m互素）就称之为一个与模m互素的剩余类，在与模m互素的全部剩余类中，各取一数所组成的集合叫做模m的一个简化剩余系。③缩系的性质：1)、对于任意一个与m互素的正整数k，即 $ \gcd(k, m) = 1 $，若 \{ a_1,a_2,\cdots,a_{\varphi(m)} \} 为模m的一个缩系，则 \{k * a_1,k * a_2,\cdots,k * a_{\varphi(m)} \} 也为模m的一个缩系。2)、(k * a_1) \cdots (k * a_{\varphi(m)}) \equiv a_1 * a_2 \cdots a_{\varphi(m)} \;(mod \; m)。 费马小定理： 定义：当 $ p $ 是素数时，对 $ \forall \; a \in \mathbb{Z}$，都有 $ a^p \equiv a \;(mod \; p) $。特别地，当 $ \gcd(a,p)=1 $ 时，有 $ a^{p-1} \equiv 1 \; (mod \; p) $。 证明： 用完系的性质证明特殊情况：已知p是素数，令集合A为模p的最小非负完系的一个子集（去掉余数0），即 $ A = \{1,2,3,\cdots,p-1\} $，显然集合A中每个元素都与p互质。对 $ \forall \; a \in \mathbb{Z} \land \gcd(a,p)=1 $，令集合 $ C = \{a,2a,\cdots,(p-1)a\} $，由完系的性质2可得集合C也是模p的一个完系的一个子集（去掉余数0），则 1 * 2 * 3 * \cdots * (p-1) \equiv a * 2a * 3a * \cdots * (p-1)a \;(mod \; p)，$ \Rightarrow (p-1)! \equiv (p-1)! * a^{p-1} \; (mod \; p) $，因为 $ \gcd\left((p-1)!,p\right)=1 $，由同余式的性质约去 $(p-1)! $ 得 $ a^{p-1} \equiv 1 \;(mod \; p) $，证毕！ 备注： ④完全剩余系（简称完系）：从模m的每个剩余类中各取一个数，得到一个由m个数组成的集合，叫做模m的一个完全剩余系。完系的性质：1）、对于m个整数，其构成模m的完系等价于其关于模m两两不同余；2）、对于任意一个与m互素的整数k，即 $ k \in \mathbb{Z} \land \gcd(k, m) = 1 $，若 $ \{a_1,a_2,\cdots,a_m\} $ 为模m的一个完系，则 \{k * a_1,k * a_2,\cdots,k * a_m \} 也为模m的一个完系。3）、$ \{0,1,\cdots,m-1\} $ 称为模m的最小非负完全剩余系。 欧拉定理： 定义：若 $a,m \in \mathbb{N}^+ \land \gcd(a,m) =1 $，则 $ a^{\varphi(m)} \equiv 1\;(mod\;m)$。 证明： 证明用到缩系的性质：令 1 \sim m 与m互素的数 x_i 构成集合A，即 A = \{x_1,x_2,\cdots,x_{\varphi(m)}\}，显然集合A为模m的一个缩系。由缩系的性质可得对于任意一个与m互素的正整数a，即 $ a \in \mathbb{N}^+ \land \gcd(a, m) = 1 $，令 C = \{a * x_1,a * x_2,\cdots,a * x_{\varphi(m)} \}，显然集合C也为模m的一个缩系，下面证明集合C是模m的一个缩系：①集合C中任意两个数模m都不同余。用反证法证明：若 \exists \; a * x_i \equiv a * x_j \;(mod\;m)，其中 x_i \neq x_j，则根据同余的性质可得 m | (ax_i-ax_j)，又因为 \gcd(a,m)=1 \land (x_i-x_j)\varphi(m) \end{cases}\pmod m 备注： 注意：当 $ b \leq \varphi(m) $ 时，不能套用第二个公式，举个栗子：$ 2^2 \;(mod\;8) \neq 2^{2\%4+4} \;(mod\;8) $。 中国剩余定理： 经典栗子：韩信点兵。求解用到的引理：①两个数不能整除，若被除数扩大（或缩小）a倍，除数不变，则商和余数也扩大（或缩小）a倍。②两个数相加，若存在一个数不能被整数a整除，则它们的和也不能被整数a整除。一元线性同余方程组： \left\{\begin{matrix} x \equiv r_1 & (mod\;m_1) \\ x \equiv r_2 & (mod\;m_2) \\ \vdots & \vdots \\ x \equiv r_n & (mod\;m_n) \end{matrix}\right.其中 m_1,m_2,\cdots,m_n均两两互质，求x的最小非负整数解。解法：令 M = \prod_{i=1}^n m_i,M_i = \frac{M}{m_i}，即M是所有模数的最小公倍数，M_i是除了当前方程的模数外其他所有方程的模数的最小公倍数，设 t_i 为同余方程 M_i \cdot t_i \equiv 1\;(mod\;m_i) 的最小非负整数解，则该方程组的一个解为x_0 = \sum_{i=1}^n M_i\cdot t_i \cdot r_i，通解为 x_0 + k * M，其中 k \in \mathbb{Z}。特别地，最小非负整数解为 (x_0\%M+M)\%M。 扩展中国剩余定理： 同样是一元线性同余方程组，若n个同余方程的模数不都两两互质，那该如何求解呢？首先我们从简单入手，考虑一下同余方程组只有两个式子的情况，目标：合二为一。 \left\{\begin{matrix} x\equiv r_1 & (mod\;m_1) \\ x\equiv r_2 & (mod\;m_2) \end{matrix}\right.将两个式子变形得 \left\{\begin{matrix} x= r_1 + m_1 \cdot k_1 \\ x= r_2 + m_2 \cdot k_2 \end{matrix}\right.联立并移项得 $ m_1 \cdot k_1=r_2-r_1+m_2\cdot k_2 $，由贝祖定理得方程有解的充要条件是 $ \gcd(m_1,m_2)\;|\;(r_2-r_1)$。若有解，则方程两边同除以 $\gcd(m_1,m_2)$ 得 \frac{m_1}{\gcd(m_1,m_2)}k_1 = \frac{r_2-r_1}{\gcd(m_1,m_2)} + \frac{m_2}{\gcd(m_1,m_2)}k_2转换为同余关系得 \frac{m_1}{\gcd(m_1,m_2)}k_1 = \frac{r_2-r_1}{\gcd(m_1,m_2)} \left(mod\;\frac{m_2}{\gcd(m_1,m_2)}\right)到这里，$k_2$ 被消去了，接着同余式两边同除以 $ \frac{m_1}{\gcd(m_1,m_2)}$ 得 k_1 \equiv inv(\frac{m_1}{\gcd(m_1,m_2)},\frac{m_2}{\gcd(m_1,m_2)}) \times \frac{r_2-r_1}{\gcd(m_1,m_2)} \left(mod\;\frac{m_2}{\gcd(m_1,m_2)}\right)其中 $inv(a,b) $ 表示a在模b意义下的乘法逆元，将同余式表示为方程得 k_1 = inv(\frac{m_1}{\gcd(m_1,m_2)},\frac{m_2}{\gcd(m_1,m_2)}) \times \frac{r_2-r_1}{\gcd(m_1,m_2)} + \frac{m_2}{\gcd(m_1,m_2)} \times y把 $k_1$ 代入 $ x= r_1 + m_1 \cdot k_1$ 得 x = r_1 + inv(\frac{m_1}{\gcd(m_1,m_2)},\frac{m_2}{\gcd(m_1,m_2)}) \times \frac{r_2-r_1}{\gcd(m_1,m_2)} \times m_1 + \frac{m_1 \cdot m_2}{\gcd(m_1,m_2)} \times y转化为同余关系得 x \equiv r_1 + inv(\frac{m_1}{\gcd(m_1,m_2)},\frac{m_2}{\gcd(m_1,m_2)}) \times \frac{r_2-r_1}{\gcd(m_1,m_2)} \times m_1 \left(mod\;\frac{m_1 \cdot m_2}{\gcd(m_1,m_2)}\right)终于，我们成功地将两个同余方程合并成一个同余方程：$ x \equiv r_2’ \;(mod\;m_2’)$，其中 r_2'= inv(\frac{m_1}{\gcd(m_1,m_2)},\frac{m_2}{\gcd(m_1,m_2)}) \% \frac{m_2}{\gcd(m_1,m_2)} \times m_1 + r_1 m_2'=\frac{m_1 \cdot m_2}{\gcd(m_1,m_2)} = lcm(m_1,m_2)亦即 $ r_2’=k_1’ \times m_1 + r_1, m_2’=lcm(m_1,m_2)$。注意：通过ext_gcd可以解出 $ k_1 $，其为模 $\frac{m_2}{\gcd(m_1,m_2)}$ 意义下的一个非负整数解，那么对于裴蜀等式 $ax+by=c$ 来说：若该方程有解，用ext_gcd求解出来的x和y的一组解是 $ x’ = \frac{c}{\gcd(a,b)}x_0,y’=\frac{c}{\gcd(a,b)}y_0$，则通解为 \left\{\begin{matrix} x= x' + \frac{b}{\gcd(a,b)} t \\ y= y' - \frac{a}{\gcd(a,b)}t &t \in \mathbb{Z} \end{matrix}\right.综上所述，每次把两个同余式合并，求解之后得到一个新的同余式，再把新的同余式和其他的联立合并，最终就可以求出满足条件的解x。]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客寒假算法基础集训营4]]></title>
    <url>%2Fposts%2Fdebac4bf.html</url>
    <content type="text"><![CDATA[A.Applese 的取石子游戏题目描述： Applese 和 Bpplese 在玩取石子游戏，规则如下：一共有偶数堆石子排成一排，每堆石子的个数为 $ a_i $。两个人轮流取石子，Applese先手。每次取石子只能取最左一堆或最右一堆，且必须取完。最后取得的石子多者获胜。假设双方都足够聪明，最后谁能够获胜呢？ 输入描述: 第一行是一个正偶数 n，表示石子的堆数。第二行是 n 个正整数 $ a_1,a_2\cdots,a_n $，表示每堆石子的个数。 输出描述: 输出一个字符串“Applese”或“Bpplese”，表示胜者的名字。 输入1242 3 3 3 输出1Applese 备注: $ 2 \leq n \leq 10^5 $$ 1 \leq a_i \leq 10^5 $$\sum a_i $ 为奇数 思路： 签道题！题解：TAG：脑洞，博弈这是一道经典的博弈问题。可以使用动态规划来解决：dp[i][j]表示进行了 i 轮，从前面取走了 j 个时候的最大收益。这个老师上课的时候教过。实际上，由于题面中的两个限制条件，可以得出先手有必胜策略：即选择所有的奇数项或者偶数项。如果奇数项的和较大，先手就取第一个，这样每一次轮到后手都只能取到偶数项。反之亦然同理。因此，作为本场比赛的签到题之一，直接输出Applese即可通过。 AC代码：1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n, x;int main() &#123; while(cin &gt;&gt; n) &#123; while(n--) cin &gt;&gt; x; cout &lt;&lt; "Applese" &lt;&lt; endl; &#125; return 0;&#125; B.Applese 走方格题目描述： 精通程序设计的 Applese 又写了一个游戏。在这个游戏中，它位于一个 n 行 m 列的方阵中的左上角（坐标为 $ (0, 0) $，行的序号为 $ 0 \sim n−1 $，列的序号为 $ 0 \sim m−1)$。现在它想不重复地走过所有格子(除了起点)，最后回到左上角的一个方案。每次只能往上下左右其中一个方向走一格。 输入描述: 仅一行两个整数 n 和 m，表示方阵的大小。保证大于 $ 1×1 $。 输出描述: 如果存在方案，则输出一行操作，包含”L”、”R”、”U”、”D”，分别表示左、右、上、下。如果有多种方案，输出任意一种即可。如果没有方案，则在一行中输出”-1”。 输入1232 22 3 输出123RDLURRDLLU 备注: $ 1 \leq n, m \leq 10 $. 思路： 做完签道题之后就开这题，一看数据很小，心里美滋滋，dfs深搜搞一搞，不过写丑了，输入 $ 8, 8 $ 之后就跑不出结果来QWQ，然后努力尝试着优化（未果），打标记发现递归在某一处进入死胡同，一直在那几个状态来回转移QWQ…..经过几个小时地挣扎之后，其实早已想到可以不用递归来解决，不过一直觉得可能是哪里没剪枝，相信只要设置一下条件……这是所有比赛以来第一次大胆尝试着用dfs写，回想当初学递归算法的时候，其实我的心里一直是抗拒的，日后的缺少训练导致现在比赛中不能轻易地AC掉某些很简单的题目，譬如本场比赛的 $ I $ 题QWQ，幸亏在队友的提示下，修改了一处（非递归）代码就AC了！感谢大佬！赛后看了一下用dfsAC的代码，果然是我写搓了，条件的构造真的太重要了！！！重新补了一下递归和模拟版（找一条固定路径）的解法。总结了一下，要多尝试，多思考，多做题！贴一下在比赛中自己缝缝补补的dfs：state：TLE！QWQ TLE代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5+5;int n,m; char ans[maxn];bool flag, vis[20][20];int dir[4][2] =&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;//下，上，左，右bool check(int x, int y)&#123; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;=m) return false; return true;&#125;void dfs(int x,int y, int cnt, int now) &#123; if(flag) return; if(!check(x,y))return; if(x == 0 &amp;&amp; y == 0) &#123; if(now +1 == n*m)&#123; flag = true; cout &lt;&lt; ans &lt;&lt; endl; return; &#125; else vis[x][y]=false,now-=1; //到原点之后，若还未访问完其他坐标点，则当前已访问的个数减1 &#125; for(int i = 0; i &lt; 4; ++i)&#123; int dx = x + dir[i][0], dy = y + dir[i][1]; if(check(dx,dy)&amp;&amp;!vis[dx][dy]) &#123; vis[dx][dy]=true; //先标记为true if(i==0) ans[cnt]='D'; //下 else if(i==1)ans[cnt]= 'U'; //上 else if(i==2)ans[cnt] ='L'; //左 else ans[cnt] = 'R'; //右 dfs(dx,dy,cnt+1,now+1); vis[dx][dy] = false; //返回时标记为false &#125; &#125;&#125;int main() &#123; while(cin &gt;&gt; n &gt;&gt; m) &#123; flag = false; memset(ans, '\0', sizeof(ans)); memset(vis,false,sizeof(vis)); dfs(0, 0, 0, 0); if(!flag) puts("-1"); &#125; return 0;&#125; AC代码1：1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 15;int n, m; bool flag, vis[maxn][maxn];int dir[4][2] = &#123;&#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;//下，右，上，左char fuck[5] = "DRUL";bool check(int x, int y)&#123; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) return false; return true;&#125;void dfs(int x, int y, string ans) &#123; //坐标：(x, y)，答案：字符串ans if(flag) return; if(x == 0 &amp;&amp; y == 0 &amp;&amp; n * m == (int)ans.size()) &#123; flag = true; cout &lt;&lt; ans &lt;&lt; endl; return; &#125; for(int i = 0; i &lt; 4; ++i) &#123; int dx = x + dir[i][0], dy = y + dir[i][1]; if(check(dx,dy) &amp;&amp; !vis[dx][dy]) &#123; vis[dx][dy] = true; //先尝试着访问该坐标点 dfs(dx, dy, ans + fuck[i]); vis[dx][dy] = false; //回溯时标记为未访问状态 &#125; &#125;&#125;int main() &#123; while(cin &gt;&gt; n &gt;&gt; m) &#123; flag = false; if(n * m % 2) &#123; puts("-1");continue;&#125; //剪枝 memset(vis, false, sizeof(vis)); dfs(0, 0, ""); if(!flag) puts("-1"); &#125; return 0;&#125; AC代码2：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;int n, m, x, y;int main() &#123; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; if(n == 1 &amp;&amp; m == 2) &#123;puts("RL"); continue;&#125; //2种特殊情况 if(n == 2 &amp;&amp; m == 1) &#123;puts("DU"); continue;&#125; if((n * m % 2) || (n == 1 || m == 1)) &#123; puts("-1"); continue;&#125; //剪枝 if(n % 2 == 0) &#123; //按偶数行构造固定路径 for(int i = 2; i &lt;= n; ++i) printf("D"); printf("R"); for(int i = n; i &gt;= 1; --i) &#123; if(i &amp; 1) &#123; for(int j = m - 1; j &gt;= 2; --j) printf("L"); if(i != 1) printf("U"); else printf("L"); &#125; else &#123; for(int j = 2; j &lt;= m - 1; ++j) printf("R"); printf("U"); &#125; &#125; &#125;else if(m % 2 == 0) &#123; //否则按偶数列构造固定路径 for(int j = 2; j &lt;= m; ++j) printf("R"); printf("D"); for(int j = m; j &gt;= 1; --j) &#123; if(j &amp; 1) &#123; for(int i = n - 1; i &gt;= 2; --i) printf("U"); if(j != 1) printf("L"); else printf("U"); &#125;else &#123; for(int i = 2; i &lt;= n - 1; ++i) printf("D"); printf("L"); &#125; &#125; &#125; puts(""); &#125; return 0;&#125; C.Applese 走迷宫题目描述： 精通程序设计的 Applese 双写了一个游戏。在这个游戏中，它被困在了一个 n×m 的迷宫中，它想要逃出这个迷宫。在迷宫中，有一些方格是水池，只有当 Applese 处于水属性的时候才可以通过；有一些方格是岩浆，只有当 Applese 是火属性的时候可以通过；有一些方格是墙壁，无论如何都无法通过；另一些格子是空地（包括起点和终点），可以自由通过。在一些空地上有神秘道具可以让 Applese 转换自己的属性（从水属性变为火属性或从火属性变为水属性，需要一个单位的时间）。已知 Applese 在一个单位的时间内可以朝四个方向行走一格，且开始处于水属性，位于空地的道具拾取后只能在该处立即使用（或者不使用），且可以多次使用。求它走出迷宫需要的最少时间。 输入描述: 第一行两个正整数 n, m 表示迷宫的大小。接下来 n 行，每行长度为 m 的字符串。描述地图。其中 ‘S’ 表示起点，’T’ 表示终点，’.’ 表示空地，’w’表示岩浆，’~’表示水池，’@’ 表示道具，’#’表示障碍。保证地图中的起点和终点只有一个，道具都位于空地。 输出描述: 输出一个整数，表示 Applese 走出迷宫的最短时间。特别地，如果 Applese 走不出迷宫，输出 “-1”。 输入1234565 5.w@...S#..~w#...w..~@w.~T 输出118 备注： $ 1 \leq n, m \leq 100 $. 思路： 典型的bfs求最短路。由于题目多加了一个状态：水、火，故求最短路也要多加一维，0：水，1：火。注意一个坑：某坐标点有道具，若有必要使用道具改变属性，则需在原地花费一个单位时间进行转化。 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 105;const int inf = 0x3f3f3f3f;int n, m, sx, sy, tx, ty, ans, dist[maxn][maxn][2], dir[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;char mp[maxn][maxn];struct node&#123; int x, y, state; node(int _x, int _y, int _state) : x(_x), y(_y), state(_state) &#123;&#125;&#125;;bool check(int x, int y) &#123; if(x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m) return false; return true;&#125;queue&lt;node&gt; que;void bfs(int x, int y, int state) &#123; while(!que.empty()) que.pop(); que.push(node(x, y, state)); dist[x][y][0] = 0; while(!que.empty()) &#123; node nod = que.front(); que.pop(); for(int i = 0; i &lt; 4; ++i) &#123; int dx = nod.x + dir[i][0], dy = nod.y + dir[i][1]; if(check(dx, dy) &amp;&amp; mp[dx][dy] != '#') &#123; if(!nod.state &amp;&amp; mp[dx][dy] == 'w') continue; if(nod.state &amp;&amp; mp[dx][dy] == '~') continue; if(dist[dx][dy][nod.state] &gt; dist[nod.x][nod.y][nod.state] + 1) &#123; dist[dx][dy][nod.state] = dist[nod.x][nod.y][nod.state] + 1; que.push(node(dx, dy, nod.state)); &#125; if(mp[dx][dy] == '@' &amp;&amp; dist[dx][dy][nod.state ^ 1] &gt; dist[dx][dy][nod.state] + 1) &#123; //若当前是道具，并且状态改变可以使得从起点到达该坐标点的最短路更短，则应该更新状态改变后对应的最短路，同时当前坐标点入队 dist[dx][dy][nod.state ^ 1] = dist[dx][dy][nod.state] + 1; que.push(node(dx, dy, nod.state ^ 1)); &#125; &#125; &#125; &#125;&#125;int main() &#123; while(cin &gt;&gt; n &gt;&gt; m) &#123; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; mp[i]; for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; m; ++j) &#123; if(mp[i][j] == 'S') sx = i, sy = j; else if(mp[i][j] == 'T') tx = i, ty = j; &#125; &#125; memset(dist, 0x3f, sizeof(dist)); bfs(sx, sy, 0); ans = min(dist[tx][ty][0], dist[tx][ty][1]); if(ans == inf) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; E.Applese 涂颜色题目描述： 精通程序设计的 Applese 叕写了一个游戏。在这个游戏中，有一个 n 行 m 列的方阵。现在它要为这个方阵涂上黑白两种颜色。规定左右相邻两格的颜色不能相同。请你帮它统计一下有多少种涂色的方法。由于答案很大，你需要将答案对 $ 10^9 + 7 $ 取模。 输入描述: 仅一行两个正整数 n, m，表示方阵的大小。 输出描述: 输出一个正整数，表示方案数对 $10^9 + 7 $ 取模。 输入1231 12 2 输出12324 备注： $ 1 \leq n,m \leq 10^{100000} $. 思路： 由于左右相邻两格的颜色不能相同，那么无论m是多少，每一行只有两种确定的填充状态，而每一行的状态又可以互相组合，所以答案就是 $ 2^n \% (10^9 + 7) $。由于n超大，并且2 与大质数 $ 1e9 + 7 $ 互质，所以要用扩展欧拉定理对指数降幂再用快速幂求解，公式： $ a ^ b \equiv a^{ b \% \varphi(p)} \;(mod \; p), \gcd(a, p) = 1 $。感想：赛后看了一下18级的通过率，本以为榜单中这题应该是全部绿色的，没想到才过了一半QWQ，看来有待加强训练。比赛前一整天就在机房里给ACM协会成员讲了数论四大定理（包括公式的由来及证明），次日比赛就用到了。从前几场比赛来看，都涉及了一些数论知识，日后要加强数学和思维方面的训练，ACM数学和思维真的很重要！！！ AC代码：123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5+5;const LL mod = 1e9+7;LL k, phi; string s1,s2;LL quick_mod(LL a, LL b) &#123; LL res = 1LL; while(b) &#123; if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int main() &#123; while(cin &gt;&gt; s1 &gt;&gt; s2)&#123; k = 0LL; phi = mod - 1LL; for(int i = 0; s1[i]; ++i) k = (k * 10 + s1[i] - '0') % phi; cout &lt;&lt; quick_mod(2LL, k) &lt;&lt; endl; &#125; return 0;&#125; F. Applese 的QQ群题目描述： Applese 有一个QQ群。在这个群中，大家互相请教问题。如 b 向 a 请教过问题，就把 a 叫做是 b 的”老板”。这样一个群中就会有很多老板。同时规定：如果 a 是 b 的老板，b 是 c 的老板，那么 a 也是 c 的老板。为了不破坏群里面和谐交流的氛围，Applese 定了一个群规：不允许出现 a 既是 b 的老板， b 又是 a 的老板。你需要帮助 Applese 判断大家是否遵守了群规。 输入描述: 第一行两个整数 n, m，表示群里的人数以及请教问题的数量。接下来 m 行，每行两个整数 a, b，表示 a 是 b 的”老板”，即 b 向 a 请教了一个问题。注：无论是否违反了群规，a 都会成为 b 的老板。 输出描述: 对于每次提问，输出一行”Yes”表示大家都遵守了群规，反之输出”No”。 输入123454 41 22 33 11 4 输出1234YesYesNoNo 备注： $ 1 \leq n \leq 10^5 $$ 1 \leq m \leq 2 \cdot 10^5 $$ 1 \leq a, b \leq n $ 思路： 一开始想用并查集，但样例中第四个输出是”No”，并且由于并查集是无向的，即已归并集合中元素之间的关系不能确定，所以用并查集的做法肯定是错的！显然这题要判断是否存在环，若存在环，即违反了群规，则之后每一次提问的输出都是”No”。正解：dfs或拓扑排序判环。由于不存在撤销操作，可以发现答案一定是一连串的Yes后再有一连串的No，所以只需二分最后一个Yes的位置即可。注意：dfs前应该建一条从b指向a老板（因为老板可能有很多个属下，若这样建图则多出了遍历儿子的时间，交一发超时，相反属下最多只有一个老板），然后dfs时，一路沿着儿子的父亲往上走，若找到已和当前相同的节点，则返回true，否则返回false。 AC代码1：123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;int n, m, a, b; bool flag;vector&lt;int&gt; vec[maxn];bool dfs(int son, int per) &#123; for(size_t i = 0; i &lt; vec[son].size(); ++i) &#123; if(vec[son][i] == per) return true; //若son的父亲是per，则返回true，表示找到环 else if(dfs(vec[son][i], per)) return true; //否则若son的父亲的父亲......和per相同，则返回true，也表示找到环 &#125; return false; //否则返回false&#125;int main() &#123; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; for(int i = 0; i &lt;= n; ++i) vec[i].clear(); flag = false; while(m--) &#123; scanf("%d%d", &amp;a, &amp;b); if(flag || dfs(a, b)) &#123; //从节点a去找，若找到其父亲为b，说明存在环 flag = true; printf("No\n"); &#125; else printf("Yes\n"), vec[b].push_back(a); //建一条从属下b指向老板a的边 &#125; &#125; return 0;&#125; AC代码2：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;int n, m, a, b, lt, rt, mid, x, y, cnt, indeg[maxn];struct EDGE&#123; int from, to; EDGE(int _u, int _v) : from(_u), to(_v) &#123;&#125;&#125;;queue&lt;int&gt; que;vector&lt;int&gt; vec[maxn];vector&lt;EDGE&gt; edges;bool check(int up) &#123; while(!que.empty()) que.pop(); memset(indeg, 0, sizeof(indeg)); cnt = 0; for(int i = 0; i &lt;= n; ++i) vec[i].clear(); for(int i = 0; i &lt;= up; ++i) vec[edges[i].from].push_back(edges[i].to), ++indeg[edges[i].to]; for(int i = 1; i &lt;= n; ++i) if(!indeg[i]) que.push(i); while(!que.empty()) &#123; x = que.front(), que.pop(), cnt++; for(size_t j = 0; j &lt; vec[x].size(); ++j) if(--indeg[vec[x][j]] == 0) que.push(vec[x][j]); &#125; return cnt == n; //若拓扑点的个数cnt与n相同，则说明当前图中不存在环&#125;int main() &#123; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; edges.clear(); for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;a, &amp;b); edges.push_back(EDGE(a, b)); &#125; lt = 0, rt = m - 1; while(lt &lt;= rt) &#123; //跳出时是 ans = lt - 1 mid = (lt + rt) &gt;&gt; 1; if(check(mid)) lt = mid + 1; else rt = mid - 1; &#125; for(int i = 0; i &lt; lt; ++i) printf("Yes\n"); for(int i = lt; i &lt; m; ++i) printf("No\n"); &#125; return 0;&#125; G.Applese 的毒气炸弹题目描述： 众所周知，Applese 是个很强的选手，它的化学一定很好。今天他又AK了一套题觉得很无聊，于是想做个毒气炸弹玩。毒气炸弹需要 k 种不同类型元素构成，Applese一共有 n 瓶含有这些元素的试剂。已知元素混合遵循 m 条规律，每一条规律都可以用 “x y c” 描述。表示将第 x 瓶试剂混入第 y 瓶试剂或者把第 y 瓶试剂混入第 x 瓶试剂，需要消耗 c 的脑力。特别地，除了这 m 条规律外，Applese 可以将任意两瓶相同元素的试剂混合，且不需要消耗脑力。Applese 想要配出毒气炸弹，就需要使 S 中含有 $ 1 \sim k $ 这 k 种元素。它想知道自己最少花费多少脑力可以把毒气炸弹做出来。 输入描述: 第一行为三个整数 n, m, k 表示 Applese 拥有的试剂的数量，混合规律的数量和所需的元素种类数。第二行为 n 个整数 $ a_1,a_2,\cdots,a_n $，分别表示每一瓶试剂的元素类型。接下来m行，每行三个整数 x, y, c，含义如题目描述中所述。不保证 x, y的试剂种类不同。 输出描述: 输出一个正整数表示最小的耗费脑力。特别地，如果无法合成出毒气炸弹，输出 “-1”。 输入123456789106 8 21 1 1 2 2 21 2 12 3 21 3 33 4 64 5 14 6 35 6 21 6 2 输出12 备注: $ 1 \leq n,k,m \leq 10^5 $$ 1 \leq x, y \leq n, x \neq y $$ 1 \leq c \leq 10^9 $ 思路： 把相同元素类型的试剂看作一个节点，然后用克鲁斯卡尔求刚好由k个点（k种元素配置毒气炸弹）组成的最小生成树，若不能找到，则输出-1。这题真的好简单QWQ。 AC代码：12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5+5;int n, m, k, x, y, z, cnt, a[maxn], fa[maxn]; LL ans;struct EDGE&#123;int from, to, val;&#125;edge[maxn];bool cmp(EDGE gax, EDGE gay) &#123;return gax.val &lt; gay.val;&#125;int find_fa(int x) &#123; return fa[x] == x ? x : fa[x] = find_fa(fa[x]);&#125;void unite(int u, int v, int w) &#123; u = find_fa(u), v = find_fa(v); if(u != v) fa[u] = v, ans += w, cnt++;&#125;void kurskal() &#123; for(int i = 0; i &lt;= n; ++i) fa[i] = i; ans = 0LL; cnt = 1; sort(edge, edge + m, cmp); for(int i = 0; i &lt; m; ++i) &#123; unite(edge[i].from, edge[i].to, edge[i].val); if(cnt == k) break; //只需选择k种元素 &#125; if(cnt == k) cout &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl;&#125;int main() &#123; while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; k) &#123; ans = 0; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; // 注意：试剂瓶编号为1~n for(int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; edge[i].from = a[x], edge[i].to = a[y], edge[i].val = z; //建边：元素到元素的关系 &#125; kurskal(); &#125; return 0;&#125; I.Applese 的回文串题目描述： 自从 Applese 学会了字符串之后，精通各种字符串算法，比如……判断一个字符串是不是回文串。这样的题目未免让它觉得太无聊，于是它想到了一个新的问题。如何判断一个字符串在任意位置(包括最前面和最后面)插入一个字符后能不能构成一个回文串？ 输入描述: 仅一行，为一个由字母和数字组成的字符串 s。 输出描述: 如果在插入一个字符之后可以构成回文串，则输出”Yes”, 否则输出”No”。 输入123applesejava 输出123NoYes 备注： $ |s| \leq 10^5 $. 思路： dfs简单过QWQ！题目要求插入一个字符后能否构成一个回文串，换个角度也就是删除任意一个字符能否构成一个回文串。因为删除的字符只有一个，且当删除字符的个数大于1，很快被return掉，所以用dfs可以简单快速求解！以后要多学学dfs的技能姿势QWQ！题解：可以认为插入和删除是等价的操作。想到这一点，这题就会好做很多。如果这个串本身就是回文串，答案一定是Yes。否则我们只需要考虑串中对称的位置不相等的两个字符，分别尝试把它们删掉后判断一下是不是回文的就行了。总结：的确，我们只需判断三次就能确定答案，因为第一个不同的地方有两种情况，尝试着删除第一个不同位置的两个字符中任意一个，若删后能构成一个回文串，显然是满足条件的，否则肯定不能构成一个回文串。好一个思维题！ AC代码1：123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5+5;char str[maxn]; bool flag;void dfs(int st, int ed, int cnt) &#123; if(flag || cnt &gt; 1) return; // 若已找到，或者要删除的字符个数大于1，则直接返回 if(st &gt;= ed) &#123;flag = true; return;&#125; //注意是大于等于， if(str[st] != str[ed]) &#123; dfs(st + 1, ed, cnt + 1); //尝试着删除左指针指向的字符，删除个数加1 dfs(st, ed - 1, cnt + 1); //尝试着删除右指针指向的字符，删除个数加1 &#125;else dfs(st + 1, ed - 1, cnt); //否则继续往两边搜&#125;int main() &#123; while(cin &gt;&gt; str) &#123; flag = false; dfs(0, strlen(str) - 1, 0); puts(flag ? "Yes" : "No"); &#125; return 0;&#125; AC代码2：12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5+5;string s1, s2, s3; int diff;int check(string pat) &#123; for(int i = 0, j = pat.size() - 1; i &lt; j; ++i, --j) if(pat[i] != pat[j]) return i; return -1;&#125;int main() &#123; while(cin &gt;&gt; s1) &#123; s2 = s3 = s1; diff = check(s1); if(diff == -1) &#123;cout &lt;&lt; "Yes" &lt;&lt; endl; continue;&#125; s2 = s2.erase(diff, 1); s3 = s3.erase(s1.size() - diff - 1, 1); if(check(s2) == -1 || check(s3) == -1) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125; J.Applese 的减肥计划题目描述: Applese 最近又长胖了，于是它打算减肥——练习举重。他在举重的时候用两只手往不同方向用力，从而把杠铃举起来。已知 Applese 两只手分别产生的力的大小，以及它们之间的夹角，试求两力合力的大小。 输入描述: 仅一行三个整数 $ f_1,f_2,a$，分别表示两只手产生的力的大小以及它们之间的夹角。 输出描述: 输出一个实数表示两力合力的大小，要求相对误差或绝对误差不超过 $ 10^{-6} $。严格来讲，如果你的答案是 a，而标准答案是 b，那么当 $ \frac{|a-b|}{max\{1,|b|\}} \leq 10^{-6} $ 时，你的答案会被认为是正确的。 输入1236 8 9010 10 60 输出12310.000000000017.3205080757 备注: $ 1 \leq f_1,f_2 \leq 100 $$ 0 \leq a \leq 180 $ 思路： 签道题！根据余弦定理：$ cosA = \frac{b^2 + c^2 - a^2}{2bc} $ 可得 $ F = \sqrt{f_1^2 + f_2^2 + 2f_1 f_2 cos \alpha }$.注意 $ \alpha $ 是弧度制，即 $1^{\circ} = \frac{\pi }{180} rad $。 AC代码：123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e6+5;const double pi = acos(-1.0);double f1, f2, a;int main() &#123; while(cin &gt;&gt; f1 &gt;&gt; f2 &gt;&gt; a)&#123; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(10) &lt;&lt; sqrt(f1 * f1 + f2 * f2 + 2.0 * f1 * f2 * cos(a * pi / 180.0)) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客竞赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客寒假算法基础集训营3]]></title>
    <url>%2Fposts%2F40de511c.html</url>
    <content type="text"><![CDATA[B.处女座的比赛资格题目描述： 处女座想出去比赛，但是又不知道学校能不能给到足够的经费。然而处女座是大众粉丝，有着很好的人缘，于是他找了一个在学校管经费的地方勤工俭学偷来了一份报销标准。由于处女座是万人迷，所以他在中间途径的每一条线路上都会发生一些故事，也许是粉丝给他发了一个200元的微信红包，也许是和他的迷妹一起吃饭花了500元。而经费负责人也实地考察了每一条路线，在每一条路上，也许是天降红包雨，也许是地生劫匪。每一条路上都有属于自己的奇遇。而经费负责人也只能根据他的故事决定这一路批下来多少经费。他会找出从宁波到比赛地的最小花费，并以此作为标准给处女座打比赛。而处女座也会选择对他来说最小花费的路线，来节省使用。处女座想知道，最终的经费是否够用，如果够还会剩下来多少钱。如果不够，他自己要自费掏出多少钱。（当然处女座和经费管理人都具有旅途中无限信贷额度，所有收入支出会在旅行结束后一起结算。） 输入描述： 输入文件第一行包含一个整数T，表示处女座要参加的比赛场数。对于每一场比赛，第一行包含两个整数N,M，分别表示旅行中的站点数（其中宁波的编号为1，比赛地的编号为N）和线路数。接下来M行，每一行包含5个整数 $ u,v,c,cnz,jffzr $，分别表示从u到v有一条单向的线路，这条线路的票价为c。处女座搭乘这条线路的时候，会得到cnz元（如果为负即为失去 $ -cnz $ 元）；经费负责人搭乘这条线路的时候，会得到 $ jffzr $ 元（如果为负即为失去 $ -jffzr $ 元）。行程保证不会形成环，并保证一定能从宁波到达比赛地。 输出描述： 对于每一场比赛，如果经费负责人给出的经费绰绰有余，则先在一行输出”cnznb!!!”，并在下一行输出他可以余下的经费；如果处女座的经费不够用，则先在一行输出”rip!!!”，并在下一行输出他需要自费的金额；如果经费负责人给出的经费正好够处女座用，则输出一行”oof!!!”。（所有输出不含引号） 输入1234513 31 2 300 600 -6002 3 100 -300 11 3 200 0 0 输出12cnznb!!!100 说明 处女座先走第一条路再走第二条路到达，总花费100元，经费负责人走第三条路，花费200元，处女座经费剩余100元。 备注: $ T \leq 10 $$ 2 \leq N \leq 10^5 $$ 1 \leq M \leq 2 \cdot 10^5 $$ 1 \leq u, v \leq N $$ 0 \leq c \leq 10^9 $$ −10^9 \leq cnz, jffzr \leq 10^9 $ 思路： 这道题比赛时没来得及写，赛后补题发现挺简单的。仔细读题，行程一定不会形成环并保证一定能从宁波达到比赛地，这不就是赤裸裸的拓扑排序？！求特殊的有向无环图（DAG）上的最短路，每次更新拓扑点的邻接点到宁波（编号为1）的最小费用，显然题目中编号1的入度肯定为0，然后按照节点拓扑顺序计算最小费用，最终一定能求出达到比赛地的最小费用。两次拓扑排序。时间复杂度为 $ O(|E| + |V|)$。坑点：①初始建边时，每条边的权值应为 $ z - cnz, z - jffzr $，边权为负数表示赚了，边权为正表示要缴过路费。②若从宁波到达比赛地的最小花费为负数，说明赚了，即不用交过路费，则需花费的费用应为0，否则就是要交的最小过路费。因此，最终应取 $ max(0, dist[n]) $。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL maxn = 2e5+5;const LL inf = 1e15;LL T, n, m, x, y, z, cnz, jffzr, indeg1[maxn], indeg2[maxn], tot1, tot2, dist1[maxn], dist2[maxn];struct EDGE&#123; LL to, val; EDGE(LL to, LL w) : to(to), val(w) &#123;&#125;&#125;;vector&lt;EDGE&gt; edge1[maxn], edge2[maxn];queue&lt;LL&gt; que;inline LL read()&#123; LL x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123; x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;LL cnz_topsrot(LL s) &#123; while(!que.empty()) que.pop(); for(LL i = 1; i &lt;= n; ++i) if(indeg1[i] == 0) que.push(i); dist1[s] = 0LL; while(!que.empty()) &#123; LL u = que.front(); que.pop(); for(LL j = 0; j &lt; edge1[u].size(); ++j) &#123; LL v = edge1[u][j].to, w = edge1[u][j].val; dist1[v] = min(dist1[v], dist1[u] + w); if(--indeg1[v] == 0) que.push(v); &#125; &#125; return max(0LL, dist1[n]); //负---赚了&lt;==&gt;0费用&#125;LL jffzr_topsrot(LL s) &#123; while(!que.empty()) que.pop(); for(LL i = 1; i &lt;= n; ++i) if(indeg2[i] == 0) que.push(i); dist2[s] = 0LL; while(!que.empty()) &#123; LL u = que.front(); que.pop(); for(LL j = 0; j &lt; edge2[u].size(); ++j) &#123; LL v = edge2[u][j].to, w = edge2[u][j].val; dist2[v] = min(dist2[v], dist2[u] + w); if(--indeg2[v] == 0) que.push(v); &#125; &#125; return max(0LL, dist2[n]);&#125;int main()&#123; T = read(); while(T--) &#123; n = read(), m = read(); memset(indeg1, 0, sizeof(indeg1)); memset(indeg2, 0, sizeof(indeg2)); for(LL i = 0; i &lt;= n; ++i) edge1[i].clear(), edge2[i].clear(), dist1[i] = dist2[i] = inf; while(m--) &#123; x = read(), y = read(), z = read(), cnz = read(), jffzr = read(); edge1[x].push_back(EDGE(y, z - cnz)); edge2[x].push_back(EDGE(y, z - jffzr)); indeg1[y]++, indeg2[y]++; &#125; tot1 = cnz_topsrot(1LL); tot2 = jffzr_topsrot(1LL); if(tot1 == tot2) printf("oof!!!\n"); else if(tot1 &lt; tot2) printf("cnznb!!!\n%lld\n", tot2 - tot1); else printf("rip!!!\n%lld\n", tot1 - tot2); &#125; return 0;&#125; C.处女座点名题目描述： 处女座觉得自己手上的经费可能不太够，于是决定给牛逼学生们带家教。一天他去上课用自己的火眼金睛感觉教室里有一个学生没有来，于是他就叫学生们报出自己的学号。已知这个班上的学号是从1开始连续编号的，处女座告诉你这个班上有多少人，想问问你到底是谁没有来。 输入描述: 输入数据共两行，第一行为一个整数N，表示班上的学生数量。第二行为一行 $ N-1 $ 个整数，表示已经来的学生的学号，按升序给出。 输出描述: 输出一个整数，为没有来的学生的学号。 输入1231 3 输出12 备注: $ 2 \leq N \leq 200000 $. 思路： 签道题！简单标记即可！ AC代码：1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 200005;int n, x, a[maxn];int main() &#123; while(cin &gt;&gt; n) &#123; memset(a, 0, sizeof(a)); for(int i = 1; i &lt; n; ++i) cin &gt;&gt; x, a[x] = 1; for(int i = 1; i &lt;= n; ++i) if(!a[i])&#123;cout &lt;&lt; i &lt;&lt; endl; break;&#125; &#125; return 0;&#125; D.处女座的训练题目描述： 处女座靠着自己的家教本领赚够了去比赛的钱，于是开启了疯狂训练。在每个夜深人静第二天不收作业的夜晚，他都会开始刷题。”今日又是一个刷题的夜晚。”他挑选了n道题开始刷，而题太多，刷不掉，理还乱（呜呜）、自己没有解决的题目每分钟都会给他带来 $ b_i $ 的疲倦值，而解决每一道题目都需要花费 $ a_i $ 分钟的时间。当然，处女座一般都是考虑清楚了再写题的，所以他在写题的时候都会精神抖擞，也就是说，当前正在写的那一题并不会给他带来任何疲劳。为了迎接后天要收的作业和明天要遇到的小姐姐，他想让今晚的刷题尽可能的轻松，那请你帮他找出最小所需要的疲倦值吧。 输入描述: 输入数据共包括 $ n + 1 $ 行，第一行包括一个n表示处女座今晚打算训练的题的数量。接下来n行，每行包括两个整数 $ a_i, b_i $，分别表示处女座刷掉本题要花费的时间和本题每分钟会带来的疲倦值。 输出描述: 一行包括一个整数，表示处女座今晚训练会产生的最小疲倦值。 输入123456766 14 54 36 28 12 6 输出186 说明 先做第6个题，增加 $ (1 + 5 + 3 + 2 + 1) * 2 = 24 $ 点疲倦值，再做第2个题，增加28点疲倦值，随后依次是第 $ 3,4,1,5 $ 道题，增加 $ 16,12,6 $ 点疲倦值。总共的疲倦值是 $ 24 + 28 + 16 + 12 + 6 = 86 $ 点。 备注: $ 2 \leq N \leq 10^5 $.$ 2 \leq a_i \leq 4 \cdot 10^6 $.$ 1 \leq b_i \leq 1000 $. 思路： 猜题+验证！出题人处女座 $ (cnznb!!!) $ 处处暗示着答案，简单计算了样例可知只需按每道题的单位疲劳值所花费的时间降序排+贪心即可！证明略。 AC代码：12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5+5;int n; LL ans, sum;struct node&#123;LL a, b;&#125; nod[maxn];bool cmp(node x, node y) &#123; return x.b * y.a &gt; y.b * x.a;&#125;int main() &#123; while(cin &gt;&gt; n)&#123; sum = ans = 0; for(int i = 0; i &lt; n;++i) cin &gt;&gt; nod[i].a &gt;&gt; nod[i].b, sum += nod[i].b; sort(nod, nod + n,cmp); for(int i = 0; i &lt; n; ++i) &#123; sum -= nod[i].b; ans += sum * nod[i].a; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; E.处女座和小姐姐题目描述: 既然昨天晚上处女座已经训练了，明天才要交作业，那今天就是平淡无奇要上课的一天了。然而处女座也想自己的小姐姐了，可是这节课是老师安排座位，处女座坐在 $ (1,1) $，而小姐姐坐在 $ (n,m) $。他们之间只能通过传纸条的方式来交流感情。对于处女座而言，他上课不想过度分心，因此并不想传纸条，只在那里趁机折千纸鹤。老师上课喜欢用”开火车”的方式让大家轮流回答问题，显然处女座作为 $ (1,1) $ 位，会被第一个叫起来回答，之后老师将依次叫起$ (2,1),(3,1), \cdots (n,1),(n,2),(n−1,2) \cdots (1,2), \cdots $ 的人起来回答问题，每个人回答问题需要1秒。处女座在自己回答完以后会以每秒1个千纸鹤的速度折叠，在小姐姐开始回答问题的时候停止折叠。处女座想知道，他这节课一共要折多少个千纸鹤？ 输入描述: 输入文件包含T+1行，第一行包含一个整数T，表示用例组数。接下来T行，每行包含两个整数n,m表示小姐姐的位置和教室的大小。 输出描述: 对于每一组用例，用一行输出一个整数，表示处女座要折的千纸鹤的个数。 输入1213 3 输出17 备注: $ 2 \leq n, m \leq 1000 $. 思路： 签道题！一开始把行和列看反了，多加了罚时QWQ，以后读题要细心点！！！ AC代码：123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int T, n, m, ans, cnt;int main() &#123; while(cin &gt;&gt; T)&#123; while(T--)&#123; cin &gt;&gt; n &gt;&gt; m; //行：m，列：n if(m &amp; 1) ans = m - 1 + m * (n - 1) - 1; else ans = m - 1 + (m - 1) * (n - 1) - 1 ; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; G.处女座和小姐姐（三）题目描述： 经过了选号和漫长的等待，处女座终于拿到了给小姐姐定制的手环，小姐姐看到以后直呼666！处女座其实也挺喜欢6这个数字的，实际上他做手环的时候选取的k=6。所以他对于包含数码6的数字极其敏感。每次看到像4567这样的数字的时候他的心就像触电了一样，想起了小姐姐。现在你要给处女座展示一系列数字，你想知道他的内心会激动多少次。对于同一个数字，他最多只会激动一次，即如果这个数是66666，他还是只会激动一次。 输入描述: 一行包括两个数字 $ l,r $，表示你给处女座展示的数字范围为 $ [l, r] $。 输出描述: 一行一个整数，表示处女座内心激动的次数。 输入110 20 输出11 备注: $ 0 \leq l \leq r \leq 10^{18} $. 思路： 裸的数位dp！！！统计不含6的数的个数，改一下模板即可。公式：j \neq 6, dp[i][j] += \sum_{k = 0 \land k \neq 6}^9 dp[i-1][k] ; j = 6, dp[i][j] = 0。 AC代码1：递归版本123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL n, m, dp[20][2], d[20];LL dfs(int pos, bool if6, bool limit)&#123; //第pos位、当前数字是否含6：if6、当前数位的上一位是否为上界：limit。 if(!pos) return 1; if(!limit &amp;&amp; dp[pos][if6] != -1) return dp[pos][if6]; LL up = limit ? d[pos] : 9, ans = 0; for(LL i = 0; i &lt;= up; ++i) &#123; if(i == 6) continue; ans += dfs(pos-1, false, limit &amp;&amp; i == up); &#125; return limit ? ans : (dp[pos][if6] = ans);&#125;LL solve(LL x)&#123; memset(d, 0, sizeof(d)); int len = 0; while(x) d[++len] = x % 10, x /= 10; return dfs(len, false, true);&#125;int main()&#123; memset(dp,-1,sizeof(dp)); while(~scanf("%lld%lld", &amp;n, &amp;m))&#123; printf("%lld\n", (m - solve(m)) - (n - 1 - solve(n-1))); &#125; return 0;&#125; AC代码2：递推版本12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL n, m, dp[20][10], dit[20];void init() &#123; memset(dp, 0, sizeof(dp)); dp[0][0] = 1LL; for(int i = 1; i &lt; 20; ++i) &#123; for(int j = 0; j &lt; 10; ++ j) &#123; if(j == 6) continue; for(int k = 0; k &lt; 10; ++k) &#123; if(k == 6) continue; dp[i][j] += dp[i - 1][k]; &#125; &#125; &#125;&#125;LL solve(LL x) &#123; memset(dit, 0, sizeof(dit)); int len = 0; LL ans = 0; while(x) &#123; dit[++len] = x % 10; x /= 10; &#125; for(int i = len; i &gt;= 1; --i) &#123; for(int j = 0; j &lt; dit[i]; ++j) &#123; if(j == 6) continue; ans += dp[i][j]; &#125; if(dit[i] == 6) break; &#125; return ans;&#125;int main()&#123; init(); while(cin &gt;&gt; n &gt;&gt; m) &#123; cout &lt;&lt; (m + 1) - solve(m + 1) - (n - solve(n)) &lt;&lt;endl; &#125; return 0;&#125; I.处女座的约会题目描述: 处女座放完了”高利贷”，拿到了不少的资金，又可以和小姐姐约会啦！（之前不还是攒钱打比赛的吗）现在处女座拿到了一份宁波市旅游地图决定和小姐姐一起去玩耍。他们来到了动物园，去参观里面的动物。但是很不幸的是，他们在游玩的途中遇到了一只恶龙。恶龙长有n个头，但经过了处女座的调教，恶龙变得善良了一些。它的n个头每个头要么仍是邪恶的头，用“1”表示，要么已经变得善良，用“0”表示，因而恶龙的n个头就可以用n位01串来表示。而此时处女座要发挥自己的勇士形象，要把所有的龙头都变成 $ 0000 \cdots 00 $ 完全善良的龙头。每一次，他可以砍掉龙最右侧的一个头，同时龙会在最左侧长出新的一个头，以保证龙头数量不变。如果他砍掉的是一个1，即邪恶的头，他可以决定龙在最左侧会长出什么样的头；但如果他砍掉了一个善良的头，那么玻璃心的恶龙将会在左侧不受控制的长出一个随机的头，既可能是善良的头，也可能是邪恶的头，而且它总会与处女座作对，尽力的破坏他的计划。现在给你一个恶龙头的初始状态，即一个01串，请帮助处女座判断一下，能否在有限步之内让全部的龙头都变成善良的龙头。 输入描述: 输入第一行T，表示用例组数。之后T行，每行一个01串S表示龙头的初始状态，“0”表示善良的头，“1”表示邪恶的头。 输出描述: 对于每组数据，处女座能否将全部的龙头变成善良的头，可以的话输出“cnznb”，不可以则输出“ljcnz”（不含引号）。 输入1211111 输出1cnznb 备注: $ T \leq 1000,|S| \leq 100 $。注意，这个问题可能没有你想的那么简单。显然，处女座必须把一些1变成0，这样才能让1的数量减少并消失。但是如果只是简单的每次把1变成0，最终不见得能取胜。比如，如果龙头的状态是101，那么去掉最右边的1并选择在左边长出一个0，则龙头会变成010；再把010右边的0去掉后，如果左边仍长出一个1，则龙头又变回了101的状态，如此反复，将永远不能得到000。 思路： 博弈+大胆猜想！比赛时模拟了很多样例后，发现都是处女座牛逼，大胆交一发，显然是“cnznb”，怎么会是“ljcnz”。（滑稽）相关证明：趣题：由0和1构成的虫子 AC代码：12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int T; string str;int main() &#123; while(cin &gt;&gt; T)&#123; while(T--) &#123; cin &gt;&gt; str; cout &lt;&lt; "cnznb" &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客竞赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客寒假算法基础集训营2]]></title>
    <url>%2Fposts%2F37d9618a.html</url>
    <content type="text"><![CDATA[A.处女座的签道题题目描述 平面上有n个点，问：平面上所有三角形面积第k大的三角形的面积是多少? 输入描述: 第一行T，表示样例的个数。对于每一组样例，第一行两个整数n和k，接下来n行，每行两个整数x,y表示点的坐标$ T \leq 80,3 \leq n \leq 100, -10^9 \leq x,y \leq 10^9 $.对于每一组样例，保证任意两点不重合，且能构成的三角形的个数不小于k 输出描述: 对于每一组样例，输出第k大三角形的面积，精确到小数点后两位（四舍五入）。 输入12345614 31 10 00 10 -1 输出10.50 说明 样例中一共能构成3个三角形，面积分别为0.5，0.5，和1，面积第3大的为0.5。 思路： ①高中知识：向量叉积求三角形面积： S_{\Delta ABC} = \frac{1}{2} \times |\vec{a} \times \vec{b}| = \frac{1}{2} \cdot |\vec{a}| \cdot |\vec{b}| \cdot sin 。设 A(x_1, y_1), B(x_2, y_2), C(x_3, y_3), \vec{AB} = (x_2 - x_1, y_2 - y_1), \vec{AC} = (x_3 - x_1, y_3 - y_1)，则 S_{\Delta ABC} = \frac{1}{2} \times |\vec{AB} \times \vec{AC}| = \frac{1}{2} \cdot |(x_2 - x_1)(y_3 - y_1) - (y_2 - y_1)(x_3 - x_1)|.②nth_elementC++标准库函数的运用：此题中，如果 $ n = 100 $，那么最多大约能构成 $ 1.6 \times 10^5 $ 个三角形。因要求第k大的三角形面积，若直接调用sort排序（$ O(nlog^n) $）大约是 $ 2.7 \times 10^6 $ 级别。若80组测试数据中n都是100，那么将是 $ 2.1 \times 10^8 $ 级别，显然这就太慢了，自测了牛客评测机，93.3%的通过率。此时就要考虑用快排或者是nth_element函数，其期望时间复杂度都是 $ O(n) $。nth_element $ (first,k^{th} - 1,last) $ 表示的是将第k小的元素放在 $ k^{th} - 1 $这个位置上，注意数组下标是从0开始的，即 $ k^{th} $ 这个位置上的元素是第 $ (k^{th} -first + 1) $ 小的（注意first是第1小的，一般first为0）。③最后要注意的就是精度问题：因为 $ x, y $ 的值相乘之后大可能会达到 $ 10^{18} $，无法用double存，所以最后需要特判 “ .00” 或者 “ .50”。备注：float： $ 2^{23} = 8388608 $，一共7位，意味着最多能有7位有效数字，但绝对能保证为6位，即float的精度位6~7位有效数字；double：$ 2^{52} = 4503596927370496 $，一共16位，即double的精度为15~16位。 AC代码：1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 105;int T, n, k;struct node&#123;LL x,y;&#125;nod[maxn];inline LL cross(node p0,node p1,node p2)&#123; return abs((p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y));&#125;vector&lt;LL&gt; vec;int main()&#123; while(~scanf("%d", &amp;T)) &#123; while(T--) &#123; scanf("%d %d", &amp;n, &amp;k); vec.clear(); for(int i = 1; i &lt;= n; ++i) scanf("%lld %lld", &amp;nod[i].x, &amp;nod[i].y); for(int i = 1; i &lt;= n - 2; ++i) for(int j = i + 1; j &lt;= n - 1; ++j) for(int k = j + 1; k &lt;= n; ++k) vec.push_back(cross(nod[i], nod[j], nod[k])); nth_element(vec.begin(), vec.begin() + k - 1, vec.end(), greater&lt;LL&gt;()); //求数组中第k大元素，因为数组从下标0开始，所以实际位置是k - 1 printf("%lld", vec[k - 1] / 2); puts(vec[k - 1] &amp; 1 ? ".50" : ".00"); &#125; &#125; return 0;&#125; B.处女座与cf题目描述 众所周知，处女座经常通过打cf来调节自己的心情。今天处女座又参加了一场cf的比赛，他知道了所有的提交记录，他想知道自己的得分和排在第几名。你知道处女座的cf账号是cnz。Codeforces规则如下：1.比赛一共2小时；2.比赛有5题，A题500分，B题1000分，C题1500分，D题2000分，E题2500分；3.得分规则如下：在第0分钟完成某一题可以得到全部的分数，每过一分钟每题的分值会衰减1/250，比如在第3分钟完成A题，能够得到 500 - 2 * 3 = 494 分；4.如果一道题是的返回结果WA或者TLE被称为错误的提交，CE视为无效的提交，AC，WA和TLE 都视为有效的提交。如果一道题你最后通过了，你会得到这道题衰减之后的分值再减去你错误提交次数 * 50，就是每次错误的提交会有50分的罚时。5.如果你通过了一道题，你的得分不会低于该题分值的30%。比如你在第50分钟通过了A，你有7次错误的提交，你的得分为 max(500 * 0.3, 500 - 2 * 50 (得分衰减) - 7 * 50(错误提交的罚时)) = 150 分。6.由于hack机制的存在，你每进行一次提交，对于这一题之前的有效提交(AC,WA,TLE)都视为错误的提交。7.一个人只有提交(AC,WA,TLE,CE)过代码，才被视为参加比赛。处女座又了解到一些信息：本场比赛没有任何选手hack别人，并且没有任何的提交fst（即只要是某题的最后一次提交通过，就视为通过这道题）。 输入描述: 第一行两个整数n和m，n为报名比赛的人数，m为提交的个数接下来n行，每行一个字符串，表示报名比赛的人的昵称。（字符串只包含小写字母，且长度小于20）接下来m行，每行的格式为Time，Submiter，Problem，Verdict。Time为提交的时间，是1到120中的一个正整数（包含1和120）,保证Time按顺序给出Submiter为提交者昵称Problem为题目名称，是’A’,’B’,’C’,’D’,’E’中的一个字母。Verdict为返回的结果，为”AC”,”WA”,”TLE”,”CE”中的一个。$ 2 \leq n \leq 500 $$ 1 \leq m \leq 10000 $ 输出描述: 如果处女座参加了比赛,输出两行:第一行为处女座的得分；第二行格式x/y,其中x为处女座的排名，y为参加比赛的总人数。如果分数相同那么排名并列。如果处女座没有参加比赛，输出”-1”。 输入12345678910113 7cnzcubermoon3 cnz A AC5 cuber A AC6 cnz B CE10 cuber C AC20 cnz B AC30 cuber D TLE100 cnz E AC 输出1229141/2 思路： 细节模拟题，主要有3个坑点。坑点1：如果一个人AC了D题，后来再次提交的状态为WA或者是CE或者是TLE，之前AC的分数应归0；坑点2：如果分数相同，则其名次应该是相同的，并且下一个不同的分数依旧按前面有效人数来计数，举个栗子：12分数： 3 2 2 1排名： 1 2 2 4 从样例来看，分数为1的排名应该是4，而不是3！！！坑点3：过滤掉没有提交的选手！！！这道题模拟题大佬们都是放最后才AC的，显然比赛策略应该先过掉简单的，再来考虑复杂的。QWQ AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n, m, t, vid, pos, cnt, ans, a[5] = &#123;500, 1000, 1500, 2000, 2500&#125;, b[5] = &#123;2, 4, 6, 8, 10&#125;, c[5] = &#123;150, 300, 450, 600, 750&#125;;string name, stat, str; bool flag; char id; map&lt;string, int&gt; mp; map&lt;int, int&gt; my;struct node&#123;int sum, socre[5], times[5]; bool vis; string man;&#125;nod[505];bool cmp(node x, node y) &#123; return x.sum &gt; y.sum;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m) &#123; flag = false; vid = 0; mp.clear(); my.clear(); cnt = 1; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; str; if(str == "cnz") flag = true; mp[str] = i; memset(nod[i].times, 0, sizeof(nod[i].times)); memset(nod[i].socre, 0, sizeof(nod[i].socre)); nod[i].vis = false; nod[i].man = str; &#125; while(m--) &#123; cin &gt;&gt; t &gt;&gt; name &gt;&gt; id &gt;&gt; stat; if(!nod[mp[name]].vis) nod[mp[name]].vis = true, vid++; if(stat == "AC") nod[mp[name]].socre[id - 'A'] = max(c[id - 'A'], a[id - 'A'] - b[id - 'A'] * t - 50 * nod[mp[name]].times[id - 'A']); else nod[mp[name]].socre[id - 'A'] = 0; //坑点1 if(stat != "CE") nod[mp[name]].times[id - 'A'] ++; &#125; if(!flag) cout &lt;&lt; -1 &lt;&lt; endl; else&#123; for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; 5; ++j) nod[i].sum += nod[i].socre[j]; sort(nod, nod + n, cmp); for(int i = 0; i &lt; n; ++i) &#123; if(!nod[i].vis) &#123; if(nod[i].man == "cnz") &#123;cout &lt;&lt; -1 &lt;&lt; endl; break;&#125; else continue; //坑点3 &#125; if(!my[nod[i].sum]) my[nod[i].sum] = cnt; //坑点2 cnt++; if(nod[i].man == "cnz") &#123; cout &lt;&lt; nod[i].sum &lt;&lt; endl; cout &lt;&lt; my[nod[i].sum] &lt;&lt; "/" &lt;&lt; vid &lt;&lt; endl; break; &#125; &#125; &#125; &#125; return 0;&#125; C.处女座的砝码题目描述 处女座热爱做物理实验，为了实验，处女座必须要精确的知道物品的质量。处女座准备自己设计一套砝码，每一个砝码都是正整数，这套砝码必须能够精确测量出n以内所有正整数的质量，处女座想要知道至少需要多少个砝码。你可以在天平的任意一边放置砝码。 输入描述: 一行，一个正整数 $ n, 1 \leq n \leq 10^{1000} $. 输出描述: 一个整数，表示最少的砝码数。 输入120 输出14 说明 你可以选择1，2，6，111=12=23=1+24=6-25=6-16=67=6+18=6+29=6+2+110=11-111=1112=11+113=11+214=11+2+115=11+6-216=11+6-117=11+618=11+6+119=11+6+220=11+6+2+1 思路： 本以为这道题比较难，加上赛中后面G、H两道简单题没写出来，于是就自闭不想了，QWQ，吸取教训，以后做不出来的先放一边，先做其他题目，毕竟有5个小时这么长，还有心态要好。赛后想了一下，发现还是挺简单的，主要是找找规律：（考虑每个砝码的质量）①1g的砝码肯定是需要的，此时能精确测量的物品质量范围为 $ [1, 1] $。②假设第二个砝码是 $ x g $，那么和之前的 $ 1 g $ 砝码能精确地测量出的范围最小值是 $ x - 1 $， 最大值是 $ x + 1 $，因为当前2个砝码能测出的范围一定是 $ [1, x + 1] $，也就是说区间是连续的，为了不和之前区间有交叉，则 $ x - 1 = 2 $，即 $ x = 3 $，所以第二个砝码的质量最大只能是 $ 3 g $。如果是 $ 4 g $，显然不能测出2这个正整数。③继续枚举，由上可知 $ 1 g, 3 g $ 砝码能测出的最大范围是 $ [1, 4] $。现假设第3个砝码的质量为 $ y \; g $，则和之前2个砝码能测出的范围最小值是 $ y - 4 $，最大值是 $ y + 4 $，为了使用更少的砝码数，每加一个砝码后其新增的能测出的范围应该不与之前区间有交叉，则 $ y - 4 = 5 $，即 $ y = 9 $，所以第3个砝码的最大值只能是 $ 9 g $。如果是 $ 10 g $，那么就不能测出5这个正整数。所以由 $ 1 g, 3 g, 9 g $ 的砝码能精确地测量出 $ [1, 13] $ 内的每个正整数……④按照此策略一直枚举下去，我们就可以发现每个砝码的质量的最大值都是3的幂次倍数，即 $ 1 - k $ 个砝码的质量分别是 $ 3^0, 3^1, 3^2, 3^3, \cdots 3^{k - 1} $，对应能测出的范围最大值分别是 $ 1, 4, 13, \cdots \frac{3^k - 1}{2}$。于是这题的规律就推出来了……最后，虽然题目中的n最大是 $ 10^{1000} $，但由于3的幂指数是爆炸式增长的，所以可以直接循环求和，没有必要取对数这么复杂的操作还容易发生精度误差的问题，java大数简单对拍即可！！！ AC代码：123456789101112131415161718import java.util.Scanner;import java.math.BigInteger;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); BigInteger n = scan.nextBigInteger(); BigInteger sum = new BigInteger("0"); BigInteger mul = new BigInteger("1"); BigInteger k = new BigInteger("3"); int ans = 0; while(sum.compareTo(n) == -1)&#123; //sum &lt; n ---&gt; 相等就跳出 ans++; //砝码个数---&gt;对应其能测出的最大范围 sum = sum.add(mul); mul = mul.multiply(k); &#125; System.out.println(ans); &#125;&#125; D.处女座与重修费题目描述 期末考试结束了，处女座发现很多人挂了大物，只能等着第二年重修，还要交400元的重修费。处女座突然想起有个学长和他讲过，如果学校哪一年缺钱了，那一年的大物试卷就会特别难。现在处女座有了所有人的成绩，处女座想知道如果所有挂科的人都在第二年重修，学校能赚多少重修费？挂科是指一门课的分数小于60分。 输入描述: 第一行一个整数n，表示考试的人数。第二行n个整数，表示每个人的成绩。$ 1 \leq n \leq 10000 $。学生的成绩为 $ 0-100 $（包括0和100）之间的整数。 输出描述: 一行，学校能赚的重修费用。 输入123454605610059 输出1800 思路: 签道题！ AC代码：123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int n,x,ans;int main() &#123; while(cin &gt;&gt; n)&#123; ans = 0; while(n--) &#123; cin &gt;&gt; x; if(x &lt; 60) ans++; &#125; cout &lt;&lt; ans * 400 &lt;&lt; endl; &#125; return 0;&#125; G.处女座与复读机题目描述 一天，处女座在牛客算法群里发了一句“我好强啊”，引起无数的复读，可是处女座发现复读之后变成了“处女座好强啊”。处女座经过调查发现群里的复读机都是失真的复读机，会固定的产生两个错误。一个错误可以是下面的形式之一：1.将任意一个小写字母替换成另外一个小写字母；2.在任意位置添加一个小写字母；3.删除任意一个字母；处女座现在在群里发了一句话，他收到了一个回应，他想知道这是不是一个复读机。 输入描述: 两行，第一行是处女座说的话s，第二行是收到的回应ts和t只由小写字母构成且长度小于100。 输出描述: 如果这可能是一个复读机输出”YES”，否则输出”NO”。 输入12345abcabcdeabcdeabcde 输出123YESYES 说明 样例1：abc-&gt;abcd-&gt;abcde样例2：abcde-&gt;abcdd-&gt;abcde 备注: 只要能经过两步变换就从s得到t就有可能是复读机。 思路： 第二场比赛的dp，没想到用dfs，直接模拟，然后一直WA，进而自闭，QWQ……以后要像大佬一样多涨点暴搜技能(流下了不做题的眼泪)。这道题一开始的想法是求最长公共子序列的长度，但是WA，赛后有位OI大佬给出一组hack数据： 12abxyabcdababxycd 可知上面的LCS为6，$ 8 - 6 \leq 2 $，输出是YES，实际上是NO，原因就是LCS没办法考虑位置。题目给的字符串长度最大只有100，最简单的做法就是暴力搜索啦，get！！！ AC代码：123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 105;int len1, len2;char s1[maxn], s2[maxn]; bool flag;void dfs(int la, int lb, int cnt) &#123; if(cnt &gt; 2 || flag || la &gt; len1 || lb &gt; len2) return; if(la == len1 &amp;&amp; lb == len2) &#123;flag = true; return;&#125; if(s1[la] == s2[lb]) dfs(la + 1, lb + 1, cnt); //跳过 else &#123; dfs(la + 1, lb + 1, cnt + 1); //替换 dfs(la + 1, lb, cnt + 1); //删除 dfs(la, lb + 1, cnt + 1); //添加 &#125;&#125;int main()&#123; while(cin &gt;&gt; s1 &gt;&gt; s2) &#123; len1 = strlen(s1), len2 = strlen(s2); flag = false; //不是复读机 if(abs(len1 - len2) &lt;= 2) dfs(0, 0, 0); puts(flag ? "YES" : "NO"); &#125; return 0;&#125; H.处女座的测验（一）题目描述 处女座进行了一场c语言的考试，要求很简单，输出2000个正整数，并且满足以下条件：1.任意两个数互质；2.任意两个数 $ x,y $，满足 $ \tau(x * y) &gt; 10 $，其中 $ \tau(n) $ 为n的因子的个数；举例：6的因子有1，2，3，6，所以 $ \tau(6) &gt; 10 $。 输入描述: 本题没有输入 输出描述: 2000行，每行一个正整数。输出的每个整数都必须在 $ 1 - 4 * 10^8 $ 之间，如果有多组答案，输出任意一组即可。 思路: 任意两个数互质，显然只能是素数，又因为任意两个数要满足其乘积的因子个数大于10，根据约数个数定理 \tau(n) = \prod_{j = 1}^k (a_j + 1) 可知一个数只需由两个素数组合而成，但不是任意的组合，因为题目中还有规定每个整数必须在 1 - 4 * 10^8，而且只需输出2000个整数。为了尽可能组成较小且满足条件的数字，就让第1个素数和第4000个素数匹配，第2个素数和第3999个素数匹配……也就是先筛选出4000个素数，然后首尾两两组合并输出，最后一个数肯定是这些数中最大的，检验一下其 (302446877 = 3 * 10^8) 不超过 4 * 10^8，即这种组合策略是正确的。QWQ AC代码：1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 4005;int cnt = 0, prime[maxn];bool check(int x) &#123; for(int i = 2; i * i &lt;= x; ++i) if(x % i == 0) return false; return true;&#125;int main()&#123; for(int i = 2; i &lt; 50000 &amp;&amp; cnt &lt; 4000; ++i) //筛选出4000个素数 if(check(i)) prime[cnt++] = i; for(int i = 0; i &lt; 2000; ++i) cout &lt;&lt; prime[i] * prime[3999 - i] &lt;&lt; endl; return 0;&#125; I.处女座的测验（二）题目描述 现在处女座顺利的完成了测验，处女座想要知道知道自己输出的结果是否正确。他希望知道自己有自己输出的数中有多少对是不满足要求的。更具体的，处女座想知道下面程序段的答案。其中 $ \tau(n) $ 为n的因子的个数。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 2005;int n, a[maxn];int main() &#123; while(cin &gt;&gt; n) &#123; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; int ans = 0; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = i + 1; j &lt;= n; ++j) &#123; if(τ(a[i] * a[j]) &lt;= 10) ans++; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 输入描述: 两行。第一行一个整数n.第二行n个整数，$ a_1, a_2, \cdots, a_n $。$ 2 \leq n \leq 2000, 1 \leq a_i \leq 3 * 10^8 $。 输出描述: 一行，一个整数ans。 输入12734 45 23 12 63 23 90 输出13 备注: 不保证任意两个整数互质。 思路： 显然此题与约数个数定理有关：\tau(n) = \prod_{j = 1}^k (a_j + 1)。做法：先求出每个数的所有素因子，以及素因子的次方数。重要剪枝：只要某个数中素因子种类数超过3，就将其过滤掉，因为其约数至少为 $ 2^4 = 16 $ 个，显然不满足题目条件，跳过。然后根据约数个数定理进行统计：有相同的素因子先累加其个数再计数，否则对每个素因子的个数单独计数。 AC代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 2005;LL n, ans, p1, p2, tot, a[maxn];vector&lt;pair&lt;LL, LL&gt; &gt; vec[maxn];int main() &#123; while(~scanf("%lld", &amp;n)) &#123; for(LL i = 0; i &lt;= n; ++i) vec[i].clear(); for(LL i = 0; i &lt; n; ++i) &#123; scanf("%lld", &amp;a[i]); for(LL j = 2; j * j &lt;= a[i]; ++j) &#123; if(a[i] % j == 0) &#123; LL cnt = 0; while(a[i] % j == 0) cnt++, a[i] /= j; vec[i].push_back(make_pair(j, cnt)); &#125; &#125; if(a[i] &gt; 1LL) vec[i].push_back(make_pair(a[i], 1LL)); &#125; for(LL i = 0; i &lt; n; ++i) &#123; if(vec[i].size() &gt; 3LL) continue; // 2^3 == 8 , 2^4 == 16 过滤掉一些数的素因子种类数超过3 for(LL j = i + 1; j &lt; n; ++j) &#123; if(vec[j].size() &gt; 3LL) continue; //同上 p1 = 0LL, p2 = 0LL, tot = 1LL; while(p1 &lt; vec[i].size() &amp;&amp; p2 &lt; vec[j].size()) &#123; //有相同的素因子，则累加其个数，再计数 if(vec[i][p1].first &gt; vec[j][p2].first) tot *= (vec[j][p2++].second + 1LL); else if(vec[i][p1].first &lt; vec[j][p2].first) tot *= (vec[i][p1++].second + 1LL); else tot *= (vec[i][p1++].second + vec[j][p2++].second + 1LL); &#125; while(p1 &lt; vec[i].size()) tot *= (vec[i][p1++].second + 1LL); //剩余部分 while(p2 &lt; vec[j].size()) tot *= (vec[j][p2++].second + 1LL); if(tot &lt;= 10LL) ans++; //如果当前tot不超过10，则满足条件，计数器加1 &#125; &#125; printf("%lld\n", ans); &#125; return 0;&#125; J.处女座的期末复习题目描述 快要期末考试了，处女座现在有n门课程需要考试，每一门课程需要花 $ a_i $小时进行复习，考试的起始时间为$ b_i $，处女座为了考试可以不吃饭不睡觉，处女座想知道他能否复习完所有的科目（即在每一门考试之前复习完该科目）。每一门课的考试时间都为两小时。 输入描述: 第一行一个整数n；第二行n个整数 $ a_1,a_2,\cdots,a_n $,表示每门课需要复习的时间；第三行n个整数 $ b_1,b_2,\cdots,b_n $,表示每门课考试的时间。$ 1 \leq n \leq 10^5 $$ 0 \leq a_i \leq 10^9 $$ 0 \leq b_i \leq 10^9 $ 输出描述: 如果处女座能复习完，输出”YES”，否则输出”NO” 输入12330 1 12 6 4 输出1YES 说明 在0-1小时复习第2门课，在1-2小时复习第3门课，在2-4小时考第1门课，在4-6小时考第3门课，在6-8小时考第2门课 备注: 考试时不能复习，保证考试时间不会重叠。复习可以拆开，只要复习时间够了即可。 思路： 按考试时间升序排，如果考试的起始时间相同，则按复习时间降序排，每次以当前一门考试科目的最终时间为右边界，同时累加当前已用时间，如果已用时超过右边界，说明当前科目不能复习完，break即可。 AC代码：1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5+5;int n, rt, now_spend; bool flag;struct node&#123; int need, st;&#125;nod[maxn];bool cmp(node a, node b) &#123; if(a.st != b.st) return a.st &lt; b.st; else return a.need &gt; b.need;&#125;int main() &#123; while(cin &gt;&gt; n) &#123; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; nod[i].need; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; nod[i].st; sort(nod, nod + n, cmp); now_spend = rt = 0; flag = false; for(int i = 0; i &lt; n; ++i) &#123; rt = nod[i].st + 2; now_spend += nod[i].need + 2; if(now_spend &gt; rt) &#123;flag = true; break;&#125; &#125; puts(flag ? "NO" : "YES"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客竞赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛客寒假算法基础集训营1]]></title>
    <url>%2Fposts%2Faed03030.html</url>
    <content type="text"><![CDATA[A.小a的计算器题目描述 小a的数学基础实在太差了，以至于他只会用计算器算数。他的计算器比较特殊，只有 +,−,×,/ (即加减乘除)四种运算。经过一番周折，小a终于算出了他想要的数，但是他却忘记了最初的数是什么。不过幸运的是他记下了整个操作序列，他想请你帮他算出最初的数。 输入描述: 第一行两个整数n,X，分别表示操作次数和最终的数接下来n行表示操作序列，每行两个数opt,x，若opt=1，则表示将当前数加x若opt=2，则表示将当前数减x若opt=3，则表示将当前数乘x若opt=4，则表示将当前数除以x 输出描述: 一个整数表示最初的数 输入123456789104 61 32 13 34 23 2923 24 34 3 输出12321314 说明： 样例1解释：$ 2 + 3 = 5 $$ 5 - 1 = 4 $$ 4 * 3 = 12 $$ 12 / 2 = 6 $ 备注： $ n \leq 100, 0 &lt; X \leq 10^{18}$.数据保证：1、 最初的数在进行操作时不会超过long long范围。2、 如果你的程序合法，那么运算中所有的数均为整数，所有的除法均为整除！3、 不会出现整数被0除的情况。 思路： 倒序模拟即可。 AC代码：123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5+5;int n, opt[105];LL y, x[105];int main() &#123; while(cin &gt;&gt; n &gt;&gt; y) &#123; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; opt[i] &gt;&gt; x[i]; for(int i = n; i &gt; 0; --i)&#123; if(opt[i] == 1) y -= x[i]; else if(opt[i] == 2) y += x[i]; else if(opt[i] == 3) y /= x[i]; else y *= x[i]; &#125; cout &lt;&lt; y &lt;&lt; endl; &#125; return 0;&#125; B.小a与”204”题目描述: 小a非常喜欢204这个数字，因为′a′+′k′=204。现在他有一个长度为n的序列，其中只含有2,0,4这三种数字。设a_i 为序列中第i个数，你需要重新排列这个数列，使得 \sum_{i = 1}^n (a_i − a_{i − 1})^2 最大(公式的含义是：每个数与前一个数差的平方的和)。注意：我们默认 $ a_0 = 0 $。 输入描述: 第一行一个整数n，接下来一行n个整数，第i个数表示 $a_i $ 输出描述: 输出一个整数，表示 \sum_{i = 1}^n (a_i − a_{i − 1})^2 的最大值。 输入：1234522 432 0 4 输出：1232036 说明： 样例1解释：按 $ (4,2) $ 排列是最优的，此时 $ sum = (4 - 0)^2 + (2 - 4)^2 = 20 $.样例2解释：按 $ (4,0,2) $ 排列是最优的，此时 $ sum = (4 - 0)^2 + (0 - 4)^2 + (2 - 0)^2 = 36 $. 备注： $ 1 \leq n \leq 10^5 $ ，保证 $ a_i $ 为 $ 2/0/4 $ 中的数。 思路： 用一个变量per标记序列中当前数位的上一位数字，然后直接贪心模拟！ AC代码：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 1e5+5;int n, cnt0, cnt2, cnt4, per, a[maxn]; LL ans;int main() &#123; while(cin &gt;&gt; n)&#123; //贪心 a[0] = cnt0 = cnt2 = cnt4 = 0; for(int i = 1;i &lt;= n; ++i)&#123; cin &gt;&gt; a[i]; if(a[i] == 2) cnt2++; else if(a[i] == 4) cnt4++; else cnt0++; &#125; //第一个先选4，否则先选2，否则只能选0 if(cnt4) ans = 16LL, cnt4--, per = 4; else if(cnt2) ans = 4LL, cnt2--, per = 2; else ans = 0LL, cnt0--, per = 0; for(int i = 2;i &lt;= n; ++i)&#123; if(per == 4)&#123; //如果上一个数是4 if(cnt0) ans += 16LL, cnt0--, per = 0; //0先与之匹配 else if(cnt2) ans += 4LL, cnt2--, per = 2; //否则2与之匹配 else cnt4--, per = 0; //否则只能选4 &#125; else if(per == 2)&#123; //如果上一个数字是2 if(cnt0 || cnt4)&#123; //可以选0或4与之匹配 if(cnt0 &gt; cnt4) ans += 4LL, cnt0--, per = 0; //如果0剩下的个数大于4剩下的个数，先选0 else ans += 4LL, cnt4--, per = 4; //否则就选4与之匹配 &#125;else cnt2--; //否则只能选2 &#125; else &#123; //如果上一个数字是0 if(cnt4) ans += 16LL, cnt4--, per = 4; //4先与之匹配 else if(cnt2) ans+=4, cnt2--, per = 2; //否则2与之匹配 else cnt0--, per = 0; //否则只能选0 &#125; &#125; cout &lt;&lt; ans &lt;&lt;endl; &#125; return 0;&#125; C.小a与星际探索题目描述 小a正在玩一款星际探索游戏，小a需要驾驶着飞船从1号星球出发前往n号星球。其中每个星球有一个能量指数p。星球i能到达星球j当且仅当 $ p_i &gt; p_j $ 。同时小a的飞船还有一个耐久度t，初始时为1号点的能量指数，若小a前往星球j，那么飞船的耐久度会变为 $ t \bigoplus p_j $(即t异或 $ p_j $，关于其定义请自行百度)小a想知道到达n号星球时耐久度最大为多少？注意：对于每个位置来说，从它出发可以到达的位置仅与两者的p有关，与下标无关。 输入描述: 第一行一个整数n，表示星球数。接下来一行有n个整数，第i个整数表示 $ p_i $. 输出描述: 一个整数表示到达n号星球时最大的耐久度若不能到达n号星球或到达时的最大耐久度为0则输出−1。 输入123456783457 456 2342 4 4 25234 233 123 2333 23 输出12345478-1253 说明 小a有两种方法到达3号星球第一种：1→2→3，最终耐久度为 $ 457 \bigoplus 456 \bigoplus 23 = 22 $；第二种：1→3，最终耐久度为 $ 457 \bigoplus 23 = 478 $。 备注: $ 1 \leq n,\forall p_i \leq 3000 $. 思路： 典型的01背包问题！定义：$ dp[i][1] $为经过第i个星球的最大耐久度，$ dp[i][0] $ 为不经过第i个星球的最大耐久度。初始值：$ dp[0][1] = $ first $ \bigoplus $ last。状态转移方程就是选与不选的问题，最后取最大即可。 AC代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 3005;int n, p, t, last, cnt, vec[maxn], ans, first; set&lt;int&gt; st;int dp[maxn][3];int main() &#123; while(~scanf("%d", &amp;n))&#123; memset(vec,0,sizeof(vec)); last = -1; cnt = 0; st.clear(); memset(dp, 0, sizeof(dp)); for(int i = 1; i &lt;= n; ++i)&#123; scanf("%d", &amp;p); //p∈[1,3000] if(i == 1) first = p; //标记第1个星球的能量指数 if(i != 1 &amp;&amp; first &lt;= p) continue; //超过第一个星球的能量指数都不能取 if(i != 1 &amp;&amp; i != n) st.insert(p); //去重 if(i == n) last = p; //标记第n个星球的能量指数 &#125; if(last == -1)&#123;puts("-1"); continue;&#125; //如果last不变，说明不小于first，直接输出-1 for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); ++it)&#123; if(*it &lt;= last)continue; //小于第n个星球的能量指数都不能要 vec[cnt++] = *it; &#125; dp[0][1] = first^last; //表示直接从1到n for(int j = 1; j &lt;= cnt; ++j)&#123; dp[j][1] = dp[0][1]^vec[j-1]; //表示经过当前星球 dp[j][1] = max(dp[j][1], max(dp[j-1][1]^dp[j][1], dp[j-1][0]^dp[j][1])); dp[j][0] = max(dp[j-1][0], dp[j-1][1]); //如果当前不选，则不选值为上一个状态选和不选的最大值 &#125; ans = max(dp[cnt][0], dp[cnt][1]); //取最大 if(!ans) puts("-1"); else printf("%d\n",ans); &#125; return 0;&#125; D.小a与黄金街道题目描述： 小a和小b来到了一条布满了黄金的街道上。它们想要带几块黄金回去，然而这里的城管担心他们拿走的太多，于是要求小a和小b通过做一个游戏来决定最后得到的黄金的数量。游戏规则是这样的：假设道路长度为n米(左端点为0，右端点为n)，同时给出一个数k(下面会提到k的用法)设小a初始时的黄金数量为A，小b初始时的黄金数量为B，小a从1出发走向n−1，小b从n−1出发走向1，两人的速度均为 $ 1 m / s $。假设某一时刻(必须为整数)小a的位置为x，小b的位置为y，若 $ gcd(n, x) = 1 $ 且 $ gcd(n, y) = 1 $ ，那么小a的黄金数量A会变为 $ A * k^x(kg) $ ，小b的黄金数量B会变为 $ B ∗ k^y(kg) $，当小a到达n−1时游戏结束。小a想知道在游戏结束时 $ A + B $ 的值。答案对 $ 10^9 + 7 $ 取模。 输入描述： 一行四个整数 $ n,k,A,B $。 输出描述: 输出一个整数表示答案 输入:1234 2 1 15 1 1 1 输出：123322 备注: 保证 $ 3 \leq n \leq 10^{18}, 1 \leq A, B, k \leq 10^{13} $. 思路： 通过前面对欧拉函数的整理，很容易得出本题的答案：(A + B) * k^{\frac{n*\varphi(n)}{2}} \; mod \; p。因为底数k与 $(10^9+7)$ 可以不互质，也可以互质，所以要用扩展欧拉定理来求解。虽然此题答案的指数不大，在 $ long \; long $ 范围内，但只要满足指数 $ b &gt; \varphi(p) $，那么就可以用扩展欧拉定理对指数进行降幂，然后套用整数快速幂求解即可。扩展欧拉定理公式： a^b\equiv \begin{cases} &a^{b\%\varphi(p)} &\gcd(a,p)=1\\ &a^b &\gcd(a,p)\neq1,b\leq\varphi(p)\\ &a^{b\%\varphi(p)+\varphi(p)} &\gcd(a,p)\neq1,b>\varphi(p) \end{cases}\pmod p实际上可以合并成这两条公式： a^b\equiv \begin{cases} &a^b & b\leq\varphi(p)\\ &a^{b\%\varphi(p)+\varphi(p)} & b>\varphi(p) \end{cases}\pmod p AC代码：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int maxn = 1e6+5;const LL mod = 1e9+7;LL n, k, A, B;LL get_Euler(LL x)&#123; //快速求欧拉函数 LL res = x; for(LL i = 2LL; i * i &lt;= x; ++i) &#123; if(x % i == 0) &#123; res = res / i * (i - 1); while(x % i == 0) x /= i; &#125; &#125; if(x &gt; 1LL) res = res / x * (x - 1); return res;&#125;LL quick_mod(LL a, LL b) &#123; //快速幂 LL res = 1LL; while(b)&#123; if(b &amp; 1) res = res * a % mod; a = a * a % mod; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; while(cin &gt;&gt; n &gt;&gt; k &gt;&gt; A &gt;&gt; B)&#123; LL b = n * get_Euler(n) / 2; LL phi = mod - 1LL; //模数的欧拉函数值phi if(b &gt; phi) cout &lt;&lt; (A + B) % mod * quick_mod(k, b % phi + phi) % mod &lt;&lt; endl; //扩展欧拉定理：适用于指数b&gt;模数的欧拉函数值phi，底数k与p既可互质也可不互质 else cout &lt;&lt; (A + B) % mod * quick_mod(k, b) % mod &lt;&lt; endl; //若b≤phi，则直接用整数快速幂求解 &#125; return 0;&#125; E.小a的轰炸游戏题目描述： 小a正在玩一款即时战略游戏，现在他要用航空母舰对敌方阵地进行轰炸地方阵地可以看做是 $n \times m $的矩形航空母舰总共会派出q架飞机。飞机有两种，第一种飞机会轰炸以 $(x_i,y_i)$ 为中心，对角线长为 $ l_i $ 的正菱形(也就是两条对角线分别于x轴，y轴平行的正方形)，而第二种飞机只会轰炸正菱形的上半部分(包括第 $ x_i $ 行)(具体看样例解释)现在小a想知道所有格子被轰炸次数的异或和注意：不保证被轰炸的格子一定在矩形范围内，若越界请忽略 输入描述: 第一行三个整数 $ n,m,q$，分别表示矩阵的长/宽/询问次数，接下来q行，每行四个整数 $opt,x,y,l$，表示飞机类型，轰炸的坐标，以及对角线长度保证l为奇数！ 输出描述: 一个整数，表示所有格子被轰炸次数的异或和 输入123454 5 41 2 2 11 3 3 51 3 2 32 2 4 3 输出12 说明12345678910111213141516171819202122每次的操作矩阵即操作后的矩阵的值如下0 0 0 0 00 1 0 0 00 0 0 0 00 0 0 0 00 0 1 0 00 2 1 1 01 1 1 1 10 1 1 1 00 0 1 0 00 3 1 1 02 2 2 1 10 2 1 1 00 0 1 1 00 3 2 2 12 2 2 1 10 2 1 1 0最后把所有元素异或后为2 备注: $ 1 \leq n,m \leq 1000 $ $ 1 \leq q \leq 5 * 10^5 $保证 $ opt=\frac{1}{2},1 \leq x,y,l \leq max(N,M) $读入文件过大，请使用较快的读入方式 思路： get新技能，开3倍空间，四个方向斜着都差分一下！ AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn = 3050; //3倍const int add = 1000; //偏移量int n, m, q, opt, x, y, l, ans, tmp, a[maxn][maxn], b[maxn][maxn], c[maxn][maxn], d[maxn][maxn];inline int read()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123; if(ch == '-')f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;void up(int x, int y, int l) &#123; a[x - l / 2][y]++, a[x + 1][y - l / 2 - 1]--; //左斜上 b[x - l / 2][y + 1]--,b[x + 1][y + l / 2 + 2]++; //右斜下&#125;void down(int x, int y, int l) &#123; c[x + 1][y - l / 2 + 1]++, c[x + l / 2 + 1][y + 1]--; //左斜下 d[x + 1][y + l / 2]--, d[x + l / 2 + 1][y]++; //右斜上&#125;int main()&#123; n = read(); m = read(); q = read(); memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); memset(d, 0, sizeof(d)); while(q--) &#123; opt = read(); x = read(); y = read(); l = read(); x += add, y += add; up(x, y, l); if(opt == 1) down(x, y, l); &#125; ans = 0; for(int i = 1; i &lt; n + 2 * add; ++i) &#123; //一定要到多出2倍，这样才能复原原矩阵中的每个值 tmp = 0; for(int j = 1; j &lt; m + 2 * add; ++j) &#123; tmp += a[i][j] + b[i][j] + c[i][j] + d[i][j]; if(i &gt; add &amp;&amp; i &lt;= n + add &amp;&amp; j &gt; add &amp;&amp; j &lt;= m + add) ans ^= tmp; //原图所在位置：正中心 a[i + 1][j - 1] += a[i][j]; //左斜上 b[i + 1][j + 1] += b[i][j]; //右斜下 c[i + 1][j + 1] += c[i][j]; //左斜下 d[i + 1][j - 1] += d[i][j]; //右斜上 &#125; &#125; printf("%d\n", ans); return 0;&#125; G.小a的排列题目描述： 小a有一个长度为n的排列。定义一段区间是”萌”的，当且仅当把区间中各个数排序后相邻元素的差为1现在他想知道包含数x,y的长度最小的”萌”区间的左右端点也就是说，我们需要找到长度最小的区间 $ [l,r] $，满足区间 $ [l,r] $ 是”萌”的，且同时包含数x和数y，如果有多个合法的区间，输出左端点最靠左的方案。 输入描述： 第一行三个整数 $ N,x,y $，分别表示序列长度，询问的两个数；第二行有n个整数表示序列内的元素，保证输入为一个排列。 输入：123455 2 35 2 1 3 48 3 56 7 1 8 5 2 4 3 输出：1232 45 8 说明： 样例1：区间 $[2, 4] = \{2,1,3\} $包含了2,3且为“萌”区间，可以证明没有比这更优的方案。 备注： 保证 $ 2 \leq n \leq 10^5, 1 \leq x, y \leq n$。 思路： 由于输入的是一个 $ 1 - n $ 的排列，所以用一个数组标记每个数字出现的位置。因为要找的最小萌区间包含 $ x, y $ 这两个数字，所以 $ x, y $ 所在区间一定满足一个排列的条件即重排后为等差数列，公差为1，判断条件为 $ maxm - minn == ed - st $。于是通过枚举当前包含 $ x, y $ 这两个数字所在的排列中还有哪些数字没有出现，而这些数字本该被包含，这样循环更新就逐渐得到所在排列在原序列中的左右端点值，暴力即可。 AC代码：123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxn=1e5+5;const int inf = 0x3f3f3f3f;int n, x, y, st, ed, minn, maxm, a[maxn], pos[maxn];int main() &#123; while(cin &gt;&gt; n &gt;&gt; x &gt;&gt; y) &#123; memset(pos, 0, sizeof(pos)); for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i], pos[a[i]] = i; //标记每个数字的出现的序号 st = min(pos[x], pos[y]), ed = max(pos[x], pos[y]); minn = inf, maxm = 0; while(1) &#123; for(int i = st; i &lt;= ed; ++i) minn = min(minn, a[i]), maxm = max(maxm, a[i]); //当前区间中取最大和最小 if(maxm - minn == ed - st) break; //如果该区间为一个排列，则退出 for(int i = minn; i &lt;= maxm; ++i) st = min(st, pos[i]), ed = max(ed, pos[i]); //更新排列中未出现的数字所在位置 &#125; cout &lt;&lt; st &lt;&lt; ' ' &lt;&lt; ed &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客竞赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数例题汇总]]></title>
    <url>%2Fposts%2F41e549f1.html</url>
    <content type="text"><![CDATA[hdu 1787 GCD AgainProblem Description Do you have spent some time to think and try to solve those unsolved problem after one ACM contest?No? Oh, you must do this when you want to become a “Big Cattle”.Now you will find that this problem is so familiar:The greatest common divisor $ GCD (a, b) $ of two positive integers a and b, sometimes written $ (a, b) $ , is the largest divisor common to a and b. For example, $ (1, 2) = 1 $, $ (12, 18) = 6 $. $ (a, b) $ can be easily found by the Euclidean algorithm. Now I am considering a little more difficult problem:Given an integer N, please count the number of the integers $ M (0&lt; M &lt; N) $ which satisfies $ (N, M) &gt; 1 $.This is a simple version of problem “GCD” which you have done in a contest recently,so I name this problem “GCD Again”.If you cannot solve it still,please take a good think about your method of study.Good Luck! Input Input contains multiple test cases. Each test case contains an integers $ N (1&lt;N&lt;100000000) $. A test case containing 0 terminates the input and this test case is not to be processed. Output For each integers N you should output the number of integers M in one line, and with one line of output for each line in input. Sample Input123240 Sample Output1201 思路：1求小于n且与n不互质的正整数的个数。 AC代码：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;const int maxn = 1e6+5;LL n;LL get_Euler(LL x)&#123; LL res = x; for(LL i = 2LL; i * i &lt;= x; ++i) &#123; if(x % i == 0) &#123; res = res / i * (i - 1); while(x % i == 0) x /= i; &#125; &#125; if(x &gt; 1LL) res = res / x * (x - 1); return res;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; cout &lt;&lt; n - 1 - get_Euler(n) &lt;&lt; endl; &#125; return 0;&#125; hdu 2824 The Euler functionProblem Description The Euler function phi is an important kind of function in number theory, $ (n) $ represents the amount of the numbers which are smaller than n and coprime to n, and this function has a lot of beautiful characteristics. Here comes a very easy question: suppose you are given a, b, try to calculate $ (a)+ (a+1)+….+ (b) $. Input There are several test cases. Each line has two integers $ a, b (2&lt;a&lt;b&lt;3000000) $ . Output Output the result of $ (a)+ (a+1)+….+ (b) $. Sample Input13 100 Sample Output13042 思路： 打表求欧拉函数值前缀和，注意只需开一个数组就够了，避免超内存。 AC代码：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;const LL maxn = 3e6+5;LL a, b, phi[maxn];void phi_table() &#123; phi[0] = 0LL, phi[1] = 1LL; //1的欧拉函数值为1，唯一与1互质的数 for(LL i = 2; i &lt; maxn; ++i) phi[i] = i; //先初始化为其本身 for(LL i = 2; i &lt; maxn; ++i) &#123; if(phi[i] == i) &#123; //如果欧拉函数值仍为其本身，说明i为素数 for(LL j = i; j &lt; maxn; j += i) //把i的欧拉函数值改变，同时也把能被素因子i整除的数的欧拉函数值改变 phi[j] = phi[j] / i * (i - 1); &#125; &#125; for(LL i = 2LL; i &lt; maxn; ++i) phi[i] += phi[i - 1];&#125;int main()&#123; phi_table(); //预处理打表 while(cin &gt;&gt; a &gt;&gt; b) &#123; cout &lt;&lt; phi[b] - phi[a - 1] &lt;&lt; endl; &#125; return 0;&#125; hdu 3501 Calculation 2Problem Description Given a positive integer N, your task is to calculate the sum of the positive integers less than N which are not coprime to N. A is said to be coprime to B if A, B share no common positive divisors except 1. Input For each test case, there is a line containing a positive integer $ N(1 ≤ N ≤ 1000000000) $. A line containing a single 0 follows the last test case. Output For each test case, you should print the sum module 1000000007 in a line. Sample Input123340 Sample Output1202 思路： 求小于n且与n不互质的所有正整数之和，公式：$ [\frac{n(n - 1)}{2} - \frac{n*\varphi(n)}{2}] mod \; 1000000007 $. AC代码：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;const int maxn = 1e6+5;const LL mod = 1000000007;LL n;LL get_Euler(LL x)&#123; LL res = x; //初始值 for(LL i = 2LL; i * i &lt;= x; ++i) &#123; if(x % i == 0) &#123; res = res / i * (i - 1); //先除后乘，避免数据过大 while(x % i == 0) x /= i; &#125; &#125; if(x &gt; 1LL) res = res / x * (x - 1); //若x大于1，则剩下的x必为素因子 return res;&#125;int main()&#123; while(cin &gt;&gt; n &amp;&amp; n) &#123; cout &lt;&lt; (n * (n - 1) / 2 - n * get_Euler(n) / 2) % mod &lt;&lt; endl; &#125; return 0;&#125; hdu 2588 GCDProblem Description The greatest common divisor $ GCD(a, b) $ of two positive integers a and b,sometimes written $ (a,b) $, is the largest divisor common to a and b,For example,$ (1, 2) = 1, (12,18)=6 .(a,b) $ can be easily found by the Euclidean algorithm. Now Carp is considering a little more difficult problem:Given integers N and M, how many integer X satisfies $ 1 \leq X \leq N $ and $ (X, N) \geq M $. Input The first line of input is an integer $ T(T \leq 100) $ representing the number of test cases. The following T lines each contains two numbers N and M$ (2 \leq N \leq 1000000000, 1 \leq M \leq N) $, representing a test case. Output For each test case,output the answer on a single line. Sample Input123431 110 210000 72 Sample Output12316260 思路： $ \because GCD(X, N) \geq M, X \in [1,N], \therefore GCD(X, N) $ 一定是N的约数。假设我们已经知道N的一个约数为 $ P(P \geq M) $，则问题转换成在 $ [1,N] $ 内有多少个数X，满足$ GCD(X, N) = P $ (假设P是一个已知值)，接下来就是枚举每个 $ P(P \geq M) $，累加每个P对应X的个数。但是对于每个不小于M的N的约数P去计算满足$ GCD(X, N) \geq M $ 的X的个数的情况可能比较复杂，需要考虑的情况比较多，简单的想法是：在 $ [1,N] $内用 $ O(NlogN) $ 的时间复杂度判断一下 $ GCD(X, N) $ 是否不小于M，但是题目中N最大为$ 10^{10} $，这肯定是超时的了。因此进一步推导：$ \because GCD(X, N) = P, \therefore GCD(\frac{X}{P}, \frac{N}{P}) = 1 $（很明显 $ \frac{X}{P} $ 与 $ \frac{N}{P} $ 互质），又 $\because X \leq N $，$\therefore \frac{X}{P} \leq \frac{N}{P} $，而问题是求X的个数，结合欧拉函数的定义可知即求小于 $ \frac{N}{P} $ 且与其互质的正整数 $ \frac{X}{P} $ 的个数，即求 $ \varphi(\frac{N}{P}) $。对于N的每个约数P，我们只需从1枚举到 $ \sqrt{N} $ 即可，因为 $ \frac{N}{P} $ 可以得到N的另一个约数（相当于枚举了N的所有约数），这样时间复杂度就大大降低了。 AC代码：12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;const int maxn = 1e6+5;const LL mod = 1000000007;int T; LL n, m, ans;LL get_Euler(LL x)&#123; LL res = x; //初始值 for(LL i = 2LL; i * i &lt;= x; ++i) &#123; if(x % i == 0) &#123; res = res / i * (i - 1); //先除后乘，避免数据过大 while(x % i == 0) x /= i; &#125; &#125; if(x &gt; 1LL) res = res / x * (x - 1); //若x大于1，则剩下的x必为素因子 return res;&#125;int main()&#123; while(cin &gt;&gt; T) &#123; while(T--) &#123; cin &gt;&gt; n &gt;&gt; m; ans = 0LL; for(LL i = 1LL; i * i &lt;= n; ++i) &#123; if(n % i) continue; //跳过不是n的约数 if(i &gt;= m &amp;&amp; i * i != n) ans += get_Euler(n / i); //约数i不小于m，累加phi[n/i]，如果i*i==n，只算一次即可 if(n / i &gt;= m) ans += get_Euler(i); //另一个约数n/i不小于m，累加phi[n/(n/i)]=phi[i] &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; poj 2480 Longge’s problemDescription Longge is good at mathematics and he likes to think about hard mathematical problems which will be solved by some graceful algorithms. Now a problem comes: Given an integer $ N(1 &lt; N &lt; 2^{31}) $,you are to calculate \sum gcd(i, N), 1 \leq i \leq N. “Oh, I know, I know!” Longge shouts! But do you know? Please solve it. Input Input contain several test case. A number N per line. Output For each N, output \sum gcd(i, N), 1 \leq i \leq N, a line Sample Input1226 Sample Output12315 思路1： 给出一个数n，求 $ 1-n $ 这n个数与n的最大公约数之和。举个栗子：当$ n = 4 $ 时，1，2，3，4与4的最大公约数分别为1，2，1，4，累加和为8。正解：$ 1-n $ 中每个数与n的最大公约数肯定是n的一个因子，所以我们只需要枚举n的每一个因子 $ x \in [1, \sqrt{n}] $ ，然后看有多少个满足 $ gcd(k, n) == x $，即求满足 $ gcd(\frac{k}{x}, \frac{n}{x}) == 1 $ 中k的个数（用欧拉函数求解），则公式为：\sum_{x|n}^n x * [gcd(\frac{k}{x}, \frac{n}{x}) == 1]。 AC代码1：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;const int maxn = 1e6+5;LL n, ans;LL get_Euler(LL x)&#123; LL res = x; for(LL i = 2LL; i * i &lt;= x; ++i) &#123; if(x % i == 0) &#123; res = res / i * (i - 1); while(x % i == 0) x /= i; &#125; &#125; if(x &gt; 1LL) res = res / x * (x - 1); return res;&#125;int main()&#123; while(cin &gt;&gt; n) &#123; ans = 0LL; for (LL i = 1LL; i * i &lt;= n; ++i) &#123; if(n % i == 0) &#123; ans += i * get_Euler(n / i); if(i * i != n) ans += n / i * get_Euler(i); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 思路2： 思路和上面相同，\because n = p_1^{k_1}p_2^{k_2} \cdots p_m^{k_m}，\therefore 将问题求解转换一下 gcd(i, n) == p_i^j，其中 j \leq k_i 即求 \sum_{p_i^j|n}^n p_i^j * [gcd(\frac{i}{p_i^j}, \frac{n}{p_i^j}) == 1]，化简公式得 \varphi(p_i^{k_i}) = (k_i + 1) * p^{k_i} - k_i * p^{k_i - 1}，再根据积性函数的性质得 \varphi(n) = \prod_{i = 1}^m \varphi(p_i^{k_i})。时间复杂度是 O(\sqrt{n})。 AC代码2：123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;LL n;LL solve(LL x) &#123; LL p_i, k, ans = 1LL; for(LL i = 2LL; i * i &lt;= x; ++i) &#123; if(x % i == 0) &#123; p_i = 1LL, k = 0; while(x % i == 0) &#123;k++, p_i *= i, x /= i;&#125; ans *= (k + 1) * p_i - k * p_i / i; //(k+1)*p^k - k*p^(k-1) &#125; &#125; if(x &gt; 1LL) ans *= 2 * x - 1LL; return ans;&#125;int main() &#123; while(cin &gt;&gt; n) &#123; cout &lt;&lt; solve(n) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法训练</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论笔记整理1]]></title>
    <url>%2Fposts%2Fcd54672d.html</url>
    <content type="text"><![CDATA[同余定理： 给定一个正整数 $ m $，如果两个整数 $ a $ 和 $ b $ 满足 $ a-b $ 能够被 $ m $ 整除，即 $\frac{a-b}{m} $ 为一个整数，那么就称整数 $ a $ 与 $ b $ 对模 $ m $ 同余，记作 $ a \equiv b \;(mod \; m) $。对模 $ m $ 同余是整数的一个等价关系。（自反、对称、传递） 性质与证明：1、自反性：$ a \equiv a \;(mod\;m) $；2、对称性：若 $ a \equiv b \; (mod \; m)$，则 $ b\equiv a \;(mod \; m) $；3、传递性：若 $ a \equiv b \; (mod \; m) $，$ b \equiv c \; (mod \; m) $，则 $ a \equiv c \;(mod \; m) $；4、同余式相加：若 $ a \equiv b \; (mod \; m) $，$ c \equiv d \; (mod \; m) $， 则 $ a \pm c \equiv b \pm d \; (mod \; m) $； 证明： $ a \equiv b \; (mod \; m) $，$ c \equiv d \; (mod \; m) \Rightarrow m | ( a - b ) $ , $ m | (c - d) $$ \Rightarrow m|[(a - b) \pm (c - d)] \Rightarrow m | [(a \pm b) - (c \pm d)] \Rightarrow a \pm c \equiv b \pm d \; (mod \; m) $. 5、同余式相乘：若 $ a \equiv b \; (mod \; m) $，$ c \equiv d \; (mod \; m) $， 则 $ ac \equiv bd \; (mod \; m) $. 证明：因为 $ ac - bd = ac - bc + bc - bd = c(a - b) + b(c - d) $ ，且 $ m | ( a - b ) $ , $ m | (c - d) $，所以 $ m | (ac - bd) $ ，即 $ ac \equiv bd \; (mod \; m) $. 6、除法：若 $ ac \equiv bc \; (mod \; m) $ ，$ c \neq 0 $，则 $ a \equiv b \; (mod \; \frac{m}{gcd(c, m)}) $. 特殊地，若 $ gcd(c, m) = 1 $ 时，则 $ a \equiv b \; (mod \; m) $.举个栗子：$ 14 \equiv 6 \;(mod \; 8) \Rightarrow 7 \equiv 3 \;(mod \;4) $，此时 $ gcd(14, 8) = 2 $。 7、幂运算：若 $ a \equiv b \; (mod \; m) $，则 $ a^n \equiv b^n \; (mod \; m) $. 说明：左边每个数取模m都同余于对应右边的每一个数，显然等式恒成立。 8、若 $ a \equiv b \; (mod \; m)$，$ n | m $，则 $ a \equiv b \; (mod \; n) $.9、若 $ a \equiv b \; (mod \; m_i)$，$ (i = 1, 2, \cdots k) $, 则 $ a \equiv b \; (mod \; [m_1, m_2, \cdots, m_k])$。 其中 $ [m_1, m_2, \cdots, m_k] $ 表示 $ m_1, m_2, \cdots, m_k $ 的最小公倍数。 同余转换： $ (a \pm b) \; mod \; p = (a \; mod \; p \pm b \; mod \; p) \; mod \; p $； (a * b) \; mod \; p = (a \; mod \; p * b \; mod \; p) \; mod \; p；除运算：$ (a / b) \; mod \; p = [(a \; mod \; p) / (b \; mod \; p)] \; mod \; p $，要用乘法逆元!!!举个栗子：$ (100 / 50) \; mod \; 20 == 2 \neq [(100 \; mod \; 20) / (50 \; mod \; 20)] \; mod \; 20 == 0 $. 欧几里德算法：（辗转相除法） 定义：求整数a和b的最大公约数，其中a、b不全为0.定理：设 $ a = qb + r $， 其中 $ a, b, q, r \in \mathbb{Z} $， 则 $ gcd(a, b) = gcd(b, r)$.证明：若d是a和b的公因子，即 $ d | a \land d | b $，则 $ d | b \land d | [r = (a - qb)]$；若d是b和r的公因子，即 $ d | b \land d | r $，则 $ d | (qb + r) $，即 $ d | a $.于是， a和b的公因子集合与b和r的公因子集合相同。继而，其最大公因子相同，即证。备注：任意一个非0整数和0的约数是该整数的所有约数，最大公约数为其本身。因为0被任意一个非0整数整除，所以任意一个非0整数都是0的约数。 贝祖定理： 定理：$ \forall \; a, b \in \mathbb{Z} $，$ \exists \; x, y \in \mathbb{Z} $，使得 $ ax + by = gcd(a, b) $.证明：若 $ ax + by = d = gcd(a, b) $，则 $ d | a, d | b $，即 $ \forall \; x, y \in \mathbb{Z} $，都有 $ d | (ax + by) $。因此，一定存在整数解x、y。设 $ s $ 是 Q::=\{h \in \mathbb{Z}| h = ax + by，其中 a, b, x, y \in \mathbb{Z}\}中的最小正整数，即 $ \exists \; x_0, y_0 \in \mathbb{Z} $，有 $ s = ax_0 + by_0 $。设 $ q = \left \lfloor \frac{a}{s} \right \rfloor $，则 $ r = a \; mod \; s = a - qs = a - q(ax + by) $$= a(1 - qx) + b(-qy) \Rightarrow r \in Q $。又 $ 0 \leq r &lt; s $，所以 $ r = 0 \Rightarrow s | a $。同理 $ s | b $，说明s是a和b的公约数，则 $ s \leq d $。因为 $ \forall \; x, y \in \mathbb{Z} $，都有 $ d | (ax + by) \Rightarrow d |(x_0 + y_0) = d | s $，则 $ d \leq s $，所以 $ s = d = gcd(a, b) $，即证。由此还可知 $ \forall \; a, b \in \mathbb{Z} $，$ gcd(a, b) $ 是线性组合 $ (ax + by) $ 的最小正整数。 裴蜀定理： $ \forall \; a, b \in \mathbb{Z} $，方程 $ ax + by = c $ 有整数解，当且仅当 $ gcd(a, b)|c $。证明：充分性：设 $ d = gcd(a, b) $，由贝祖定理可知一定有整数解 $ x_0, y_0 $ 使得 $ ax_0 + by_0 = d $。因为 $ d | c $，所以 $ \exists k \in \mathbb{Z} $，使得 $ c = kd = k(ax_0 + by_0) $$ = a(kx_0) + b(ky_0) $，即方程有整数解 $ kx_0, ky_0 $。必要性：$ \exists \; x_1, y_1 \in \mathbb{Z} $，使得 $ ax_1 + by_1 = c $，设 $ d = gcd(a, b) $，则 $ d | a, d | b $$ \Rightarrow d | (ax_1 + by_1) \Rightarrow d | c $，即证。 扩展欧几里得算法： 定义：在已知a, b求解一组x，y，使它们满足贝祖等式： $ ax + by = gcd(a, b) = d $（解一定存在）。由欧几里德算法得 $ gcd(a, b) = gcd(b, a \; mod \; b) $，则 ax + by = bx_1 + (a - a / b * b)y_1 = ay_1 + b(x_1 - a / b * y_1)，即 $ x = y_1, y = x_1 - a / b * y_1 $。 乘法逆元： 若 $ ax \equiv 1(mod \; m) $，则称x是模m意义下a的乘法逆元。记 $ x =inv(a) $ 或 $ x = a^{−1} $。注意：$ gcd(a, m) = 1 $ 。求法：①将方程转化为 $ ax - my = 1 $，然后用扩展欧几里得算法求解即可。②根据欧拉定理：若 $a,m \in \mathbb{N}^+ \land \gcd(a,m) =1 $，则 $ a^{\varphi(m)} \equiv 1\;(mod\;m)$；根据同余式可乘性质可得 $ a^{\varphi(m)} \times a^{-1} \equiv 1 \times a^{-1} \;(mod\;p) \Rightarrow a^{-1} \equiv a^{\varphi(m)-1} \;(mod\;p)$，即 $ inv(a) = a^{\varphi(m)-1} \;(mod\;p)$，然后用整数快速幂取模求解即可！③线性求 $ 1\sim p-1 $ 的乘法逆元：时间复杂度是 $ O(p) $。注意：p是素数。推导如下：首先，$1^{-1} \equiv 1\;(mod\;p)$。那么 $ \forall \;i \in [2,p-1]$，必 $\exists\; k,r$，使得 $ p=k \times i + r$，其中 $ k,r \in \mathbb{Z} \land r &lt; i$。$\because p \equiv 0\;(mod\;p) $，$\therefore k \times i + r \equiv 0\;(mod\;p)$，恒等式两边同乘以 $ i^{-1} \cdot r^{-1} $ 得 $ k\cdot r^{-1} + i^{-1} \equiv 0 \;(mod\; p) $$ \Rightarrow i^{-1} \equiv -k\cdot r^{-1} \;(mod\; p) \Rightarrow i^{-1} \equiv (p-\left\lfloor\frac{p}{i}\right\rfloor)\cdot \left(p\bmod i\right)^{-1} \;(mod \;p) $（取正整数）。]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数模板]]></title>
    <url>%2Fposts%2Fee22c535.html</url>
    <content type="text"><![CDATA[两种求解方法！ 快速求欧拉函数：$ O(\sqrt{n}) $1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;const int maxn = 1e6+5;LL n;LL get_Euler(LL x)&#123; LL res = x; //初始值 for(LL i = 2LL; i * i &lt;= x; ++i) &#123; if(x % i == 0) &#123; res = res / i * (i - 1); //先除后乘，避免数据过大 while(x % i == 0) x /= i; &#125; &#125; if(x &gt; 1LL) res = res / x * (x - 1); //若x大于1，则剩下的x必为素因子 return res;&#125;int main()&#123; while(cin &gt;&gt; n) &#123; cout &lt;&lt; get_Euler(n) &lt;&lt; endl; //求n的互质数的个数 cout &lt;&lt; n * get_Euler(n) / 2 &lt;&lt; endl; //求n的所有互质数之和 &#125; return 0;&#125; 埃氏筛法预处理打表：$ O(nlog^{log^n})$12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long LL;const int maxn = 1e6+5;int n, phi[maxn];void phi_table() &#123; phi[0] = 0, phi[1] = 1; //1的欧拉函数值为1：唯一与1互质的数 for(int i = 2; i &lt; maxn; ++i) phi[i] = i; //先初始化为其本身 for(int i = 2; i &lt; maxn; ++i) &#123; if(phi[i] == i) &#123; //如果欧拉函数值仍为其本身，说明i为素数 for(int j = i; j &lt; maxn; j += i) //把i的欧拉函数值改变，同时也把能被素因子i整除的数的欧拉函数值改变 phi[j] = phi[j] / i * (i - 1); &#125; &#125;&#125;int main()&#123; phi_table(); //预处理打表 while(cin &gt;&gt; n) &#123; cout &lt;&lt; phi[n] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM模板</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数]]></title>
    <url>%2Fposts%2Ff60286b9.html</url>
    <content type="text"><![CDATA[定义： 对于正整数n，欧拉函数是小于n的正整数中与n互质的数的个数$(\varphi(1)=1)$。此函数以其首名研究者欧拉命名，它又称为$\varphi$函数、欧拉商数等。举个栗子：$\varphi(8)=4$，因为1,3,5,7均和8互质。 性质与证明：①通式：$ \varphi (x) = x\prod _{i = 1}^{k} (1 - \frac{1}{p_i}) = x(1 - \frac{1}{p_1})(1 - \frac{1}{p_2})\cdots (1 - \frac{1}{p_k}) $. 其中 p_1, p_2, \cdots, p_n 为x的所有素因子，x > 1 且 x \in N^+，规定 $ \varphi(1) = 1 $（唯一与1互质的数就是1本身）。 注意：每种素因子只有一个。证明思路：讨论x的所有素因子 p_i ，只要是 p_i 的倍数的数都不是x的互质数。用容斥定理证明： A\cup B \cup C = A + B + C - A \cap B - B \cap C - C \cap A + A \cap B \cap C.1)、若x是素数，则 \varphi(x) = x - 1.证明：因为素数x的质因子只有1和它本身，而x和x不互质，所以 \varphi(x) = x - 1.2)、若x不是素数，则只需除去x的质因子p_i 和 p_i的倍数的数即可。设x的所有素因子为 p_1, p_2, \cdots, p_k，根据容斥原理得：与x不互质的数的个数为：\frac{x}{p_1} + \frac{x}{p_2} + \cdots \frac{x}{p_k} - \frac{x}{p_1p_2} - \frac{x}{p_1p_k} - \cdots - \frac{x}{p_{k-1}p_k} + \cdots（注：每个分式的符号由该分式的分母中素数的个数来决定：奇加偶减）则与x互质的数的个数为： x - (\frac{x}{p_1} + \frac{x}{p_2} + \cdots \frac{x}{p_k} - \frac{x}{p_1p_2} - \frac{x}{p_1p_k} - \cdots - \frac{x}{p_{k-1}p_k} + \cdots) = x(1 - \frac{1}{p_1})(1 - \frac{1}{p_2})\cdots (1 - \frac{1}{p_k}) = \varphi (x) = x\prod _{i = 1}^{k} (1 - \frac{1}{p_i})，即证。 ②若n为素数p的k次幂，则有 $ \varphi (n) = \varphi (p^k) = p^k(1-\frac{1}{p}) = p^k - p^{k-1} = (p - 1)p^k $. 证明：因为除了 $ p $ 的倍数外，其他数都与n互质。根据容斥原理得 $ \varphi (n) = $ 总数 - $p$ 的倍数的个数 = $ (p^k - 1) - (\frac{p^k}{p} - 1) = p^k - p^{k -1} = (p - 1)p^k$ ，即证。 ③欧拉函数是积性函数，但不是完全积性函数。 若m与n互质，则$ \varphi(mn) = \varphi(m)\varphi(n)$.特殊地，当m=2，若n为奇数时，$ \varphi(2n)= \varphi(n)$.证明：因为m与n互质，所以它们没有公共的质因子。设m有a_m个质因子，n有a_n个质因子，则有 \varphi (m) \varphi (n) = mn \prod _{i = 1}^{a_m} (1 - \frac{1}{p_i})\prod _{i = 1}^{a_n} (1 - \frac{1}{p_i}) = mn \prod _{i = 1}^{a_m + a_n}(1 - \frac{1}{p_i}) = \varphi (mn).换句话说：只有那些既满足m与其互质且也满足n与其互质的数才满足条件。根据乘法原理，这些数可以互相组合，则有 \varphi(m)\varphi(n)个，即证。积性函数的性质：若将n表示成质因子分解式：n = p_1^{a_1}p_2^{a_2} \cdots p_k^{a_k}，则有 \varphi(n) = \varphi(p_1^{a_1})\varphi(p_2^{a_2}) \cdots \varphi(p_k^{a_k}). ④小于n且为n的互质数之和为 \sum_{i=1}^n i*[gcd(n, i)==1] = \frac{n*\varphi(n)}{2}。 证明用到一个推论：若 $ gcd(n, i) = 1 $，则 $ gcd(n, n-i) = 1 $（设$n &gt; i$)。下面证明这个推论：用反证法证明：假设 $ \exists k \neq 1 $，使 $gcd(n, n-i) = k $ 成立，即$gcd(n, n-i) = k \Rightarrow (k|n) \land (k|(n-i)) \Rightarrow (k|n) \land (k|i) \Rightarrow gcd(n, i) = k \neq 1 $，显然这与条件相矛盾，所以假设不成立，即原命题正确。于是问题求解变得非常简单： 通过上面的推论可知 i 和 n-i 总是成对出现，且和是n，即与n互质的所有数之和为 \sum_{i = 1}^n i*[gcd(n, i) == 1] = \frac{n*\varphi(n)}{2}下面讨论在 $ gcd(n, i) = gcd(n, n - i) = 1 $ 的前提下，是否会出现 $ n - i == i$ 时而导致重复计算呢？分两种情况来讨论：1)、若n为奇数，因为 n \neq 2 * i，所以不存在n-i=i时导致的重复计算；2)、若n为偶数，则 n = 2 * i， [gcd(n,\frac{n}{2}) = \frac{n}{2}] | n.当且仅当 $ n = 2 $ 时，$ gcd(n, \frac{n}{2}) = \frac{n}{2} = 1$，此时 \sum_{i = 1}^2 i * [gcd(2, i) == 1] = \frac{2*1}{2} = 1，显然不会重复计算；而对于 $ n &gt; 2 $ 的偶数，$ gcd(n, \frac{n}{2}) = \frac{n}{2} \neq 1$，显然不满足原条件，更别说重复计算了，即证。 备注： a、积性函数：对于任意互质的整数a和b有性质$f(ab)=f(a)f(b)$ 的数论函数。b、完全积性函数：对于任意整数a和b有性质$f(ab)=f(a)f(b)$ 的数论函数。c、在数论上，算术函数（数论函数）指定义域为正整数、陪域为复数的函数，每个算术函数都可视为复数的序列。]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛37]]></title>
    <url>%2Fposts%2F808212bd.html</url>
    <content type="text"><![CDATA[A.筱玛的快乐题目描述： 筱玛是个快乐的男孩子。寒假终于到了，筱玛决定请他的朋友们一起来快乐。对于筱玛来说，最快乐的事情莫过于翻看万年历上的日期了。一个日期是“快乐”的，当且仅当这一年的年份是一个质数，且将月份、日期写成”MM-DD”的形式后是对称的。如：”2003-01-10”是“快乐”的。筱玛有n个小伙伴，每个小伙伴都会提出一个问题，即：从”2000-01-01”这一天开始，第k个“快乐”的日期是什么。 输入描述: 第一行一个整数n。接下来n行，每行一个数字k，表示一次询问。 输出描述: 输出共n行，每行一个形如”YYYY-MM-DD”的日期表示答案。 输入：1234312348 输出：1232003-01-102027-11-112063-12-21 备注: 1≤n≤$10^6$，保证答案存在且答案年份为4位数。 思路： 线性筛$O(1)$打表，坑：卡C++的输入输出，要用C语言的输入输出== AC代码：12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const LL maxn=3e6+5;const LL maxm=166670;int T,n;vector&lt;LL&gt; ans;bool isp[maxn];LL cnt=0,prime[maxn];char str[6][8]=&#123;"-12-21","-01-10","-02-20","-03-30","-10-01","-11-11"&#125;;void euler_sieve()&#123; memset(isp,true,sizeof(isp)); memset(prime,0,sizeof(prime)); isp[0]=isp[1]=false; for(LL i=2;i&lt;maxn;++i)&#123; if(isp[i])prime[cnt++]=i; for(LL j=0;j&lt;cnt&amp;&amp;i*prime[j]&lt;maxn;++j)&#123; isp[i*prime[j]]=false; if(i%prime[j]==0)break; &#125; &#125;&#125;int main()&#123; euler_sieve();ans.clear(); for(LL i=0,num=0;num&lt;maxm&amp;&amp;i&lt;cnt;++i) if(prime[i]&gt;2000LL)ans.push_back(prime[i]),num++; while(~scanf("%d",&amp;T))&#123; while(T--)&#123; scanf("%d",&amp;n); printf("%lld%s\n",ans[n/6+(n%6&gt;0)-1],str[n%6]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>牛客竞赛</category>
      </categories>
      <tags>
        <tag>欧拉线性筛</tag>
      </tags>
  </entry>
</search>
